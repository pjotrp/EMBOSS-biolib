/* @source fraggle application
**
** Removes fragment sequences from files of hits for scop families.
**
** @author: Copyright (C) Matt Blades (mblades@hgmp.mrc.ac.uk)
** @author: Copyright (C) Jon Ison (jison@hgmp.mrc.ac.uk)
** @@
**
**
** This program is free software; you can redistribute it and/or
** modify it under the terms of the GNU General Public License
** as published by the Free Software Foundation; either version 2
** of the License, or (at your option) any later version.
** 
** This program is distributed in the hope that it will be useful,
** but WITHOUT ANY WARRANTY; without even the implied warranty of
** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
** GNU General Public License for more details.
** 
** You should have received a copy of the GNU General Public License
** along with this program; if not, write to the Free Software
** Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
**

*******************************************************************************
**  Application name
**  fraggle
**  
**  
**
**  Summary
**  Removes fragment sequences from files of hits for scop families.
**
**  
**  
**  Input and Output
**  Fraggle reads a directory of scop hits files and for each individual file 
**  writes a new scop hits file in which sequence hits deemed to be fragments 
**  have been removed.  The base names of the output files are the same as the 
**  input files.  The paths and file extensions for the scop hits files (input 
**  and output) are specified by the user.
**  
**   
**   
**  Sister applications
**  A 'scop hits file' contains sequence relatives (hits) to a single scop 
**  family found from a psiblast search of a sequence database.  The files are 
**  generated by seqsearch and are in embl-like format.
**  scop hits files are used by seqsort.
**  
**
**  
**  Notes
**  
**  
**  
**  Known bugs & warnings
**  
**  
**  
**  Description
**  This program is part of a suite of EMBOSS applications that directly or 
**  indirectly make use of the protein structure databases pdb and scop.  
**  This program is part of an experimental analysis pipeline described in an
**  accompanying document.  We provide the software in the hope that it will
**  be useful.  The applications were designed for specific research purposes
**  and may not be useful or reliable in contexts other than the described 
**  pipeline.  The development of the suite was coordinated by Jon Ison to
**  whom enquiries and bug reports should be sent (email jison@hgmp.mrc.ac.uk).
**  
**  Fragmentary protein sequences occur in the sequence databases but do not 
**  have particular biological significance.  Certain analyses will be 
**  distorted if fragmentary sequences are not filtered from the dataset.  
**  fraggle reads scop hits files and writes new scop hits file in which 
**  sequences deemed to be fragments are ommitted. 
**  
**  
**  
**  Algorithm
**  Fraggle first determines the median length of all the sequences in the 
**  input file, then discards any hit sequences which are not within a 
**  threshold percentage of the median length. The remaining sequences are
**  written to the output file.
**  
**  
**  
**  Usage 
**  An example of interactive use of fraggle is shown below.
**  Unix % fraggle
**  Removes fragment sequences from files of hits for scop families.
**  Location of scop hits files (input) [./]: testdata
**  Percentage of median length for definition of fragments [50]:
**  Location of scop hits files (output) [./]: testdata
**  Processing testdata/54894.hits
**  Processing testdata/55074.hits
**  Unix %
** 
**  
**  All the scop hits files with the file extension .hits (specified in the 
**  ACD file) in the directory /testdata were read.  In this case two 
**  files called 55074.hits and 54894.hits were read.  Two scop hits file with
**  fragment sequences removed were written to /testdata.
**  
**  The following command line would achieve the same result.
**  fraggle testdata testdata -thresh 50
**  
**  
**  
**  Input file format
**  The format of the scop hits file is described in seqsearch.c
**  
**  
**  
**  Output file format
**  The format of the scop hits file is described in seqsearch.c
**  
**  
**  
**  Data files
**  fraggle does not use a data file.
**  
**  
**  
**  Diagnostic error messages
**  
**  
**  
**  Authors
**  Matt Blades (mblades@hgmp.mrc.ac.uk)
**  Jon Ison (jison@hgmp.mrc.ac.uk)
**  
**  
**  
**  References
**  Please cite the authors.
**  
**  
**  
******************************************************************************/






#include "emboss.h"



/* @prog fraggle *******************************************************
**
** Removes fragment sequences from files of hits for scop families.
**
******************************************************************************/
int main(int argc, char **argv)
{
    AjPList      hitsin          = NULL;  /* Hits files for input                   */
    AjPDir       hitsout         = NULL;  /* Hits files for output                  */

    AjPStr      temp            = NULL;  /* Temp string                            */
    AjPStr      name            = NULL;  /* Temp string                            */
    AjPStr      line            = NULL;  /* String to hold file lines              */
    AjPStr      exec            = NULL;  /* The UNIX command line to be executed   */    

    ajint       thresh          = 0;     /* Threshold for definition of fragments  */
    ajint       start           = 0;     /* int to hold start of sequence range    */
    ajint       end             = 0;     /* int to hold end of sequence range      */
/*    ajint       num             = 0; */    /* number of nodes on list                */
    ajint       len             = 0;     /* length of sequence hit                 */
    ajint       x               = 0;     /* Loop counters                          */
    ajint       y               = 0;     /* Loop counters                          */
    ajint       median          = 0;     /* Median length of sequence hits         */
    ajint       mid             = 0;     /* Middle value of seq_len array          */
    ajint       num_hits        = 0;     /* Number of hits in file                 */

    float       score           = 0.0;   /* Float for storing length/median value  */
    
    
    AjPInt      seq_len_sort    = NULL;  /* Array to hold length of each hit seq   */
    AjPInt      seq_len         = NULL;  /* Array to hold sorted lengths           */
    AjPInt      seq_ok          = NULL;  /* Array indicating if length is > thresh */

    AjPFile     hitsPtr         = NULL;  /* Pointer to hits file                   */
    AjPFile     hitsoutPtr      = NULL;  /* Pointer to hits output file            */
     
    AjPHitlist  hitlist         = NULL;  /* Hitlist structure                      */

    AjBool      ok              = ajFalse; /* Bool                                 */

    /* Assign strings and list */
    name         = ajStrNew();
    line         = ajStrNew();
    exec         = ajStrNew();


    /* Read data from acd */
    ajNamInit("emboss");
    ajAcdInitP("fraggle",argc,argv,"DOMAINATRIX"); 
    hitsin      = ajAcdGetDirlist("hitsin");
    hitsout     = ajAcdGetDirectory("hitsout");

    thresh      = ajAcdGetInt("thresh");
    


/*    ajFmtPrint("length: %d\n", ajListLength(hitsin)); */
    

    /* Start of main application loop                         */
    /* determine median length of sequences in each hits file */
    while(ajListPop(hitsin,(void **)&temp))
    {
        /* Open hits file */
        if((hitsPtr=ajFileNewIn(temp))==NULL)
        {
            ajFileClose(&hitsPtr);
            ajWarn("Could not open hits file XXX %S XXX", temp);
            ajStrDel(&temp); 
            continue;       
        }

        ok = ajFalse;
        x = 0;
        ajFmtPrint("Processing %S\n", temp);

        /* Read through file once and determine median      */
        /* sequence length, by reading range from RA field  */
        while((ajFileReadLine(hitsPtr, &line)) && !ajStrPrefixC(line,"//"))
        {
            if(ajStrPrefixC(line, "NS"))
            {
                ajFmtScanS(line, "%*s %d", &num_hits);

                if((num_hits == 0) || (num_hits == 1))
                {
                    /* printf("Number of hits = 0 or 1...."
		       "exiting this hits file\n"); */

                    /* Set bool to false so we do NOT carry on any */
                    /* further with this hits file                 */
                    ok = ajFalse;
                }
                
                else
                {
                    /* printf("NS =%6d.....", num_hits); */
                
                    /* Create array to hold sequence lengths */
                    seq_len_sort = ajIntNewL(num_hits);
                    seq_len      = ajIntNewL(num_hits);
                    seq_ok       = ajIntNewL(num_hits);
    
                    /* Assign zeros to array elements */
                    for(y=0;y<num_hits;y++)
                    {
                        ajIntPut(&seq_ok, y, 0);
                        ajIntPut(&seq_len, y, 0);       
                        ajIntPut(&seq_len_sort, y, 0);  
                    }

                    /* Set bool to true in order to proceed */
                    ok = ajTrue;
                }    
            }
            

            /* if line starts with RA then parse sequence range */
            if((ajStrPrefixC(line, "RA")) && (ok == ajTrue))
            {
                /* Scan line for sequence range */
                ajFmtScanS(line, "%*s %d %*s %d", &start, &end);
                
                /* calculate length and assign to array */
                len = (end - (start-1));
                /*printf("len = %d\n", len);*/
        
                /* Put len into arrays */
                ajIntPut(&seq_len, x, len);
                ajIntPut(&seq_len_sort, x, len);

                /* Increment array element counter */
                x++;
            }

            else
                continue;
        }


        if(ok == ajTrue)
        {
            /* Calculate median length */
            /* Reorder seq_len_sort array into ascending order */
            for(x=0;x<num_hits;x++)
                ajSortIntInc((ajint *) ajIntInt(seq_len_sort), num_hits);

        
            /* If num_hits == even then the median = average of middle two values */
            if((num_hits % 2) == 0)
            {
                mid = (num_hits / 2);
                /*printf("mid = %d\n", mid);
                ajIntPut(&seq_len_sort, mid-1, 10000);
                  ajIntPut(&seq_len_sort, mid, 15000);
                  for(x=0;x<num_hits;x++)
                  ajFmtPrint("%4d\n", ajIntGet(seq_len_sort, x));*/
                median = (((ajIntGet(seq_len_sort, mid-1)) + (ajIntGet(seq_len_sort, mid))) / 2); 
                /* printf("median = %4d\n", median); */
            }

            /* else if num == odd number, then median = middle value */ 
            else
            {
                mid = (num_hits / 2);
                /*printf("mid = %d\n", mid);
                ajIntPut(&seq_len_sort, mid, 1000);
                for(x=0;x<num_hits;x++)
                    ajFmtPrint("%4d\n", ajIntGet(seq_len_sort, x));*/
                median = ajIntGet(seq_len_sort, mid); 
                /* printf("median = %4d\n", median); */
            }
        



            /* Go through seq_len and determine which have  */
            /* lengths > threshold and should be written to */
            /* output file                                      */

            /* Reset file pointer */
            ajFileSeek(hitsPtr, 0, 0);
        
            /* Read hitlist into structure */
            hitlist = embHitlistRead(hitsPtr);
	    
        
            /* create output file name and path */
            ajStrFromInt(&name, hitlist->Sunid_Family);
        
        
            /* Create output file */
            hitsoutPtr = ajFileNewOutDir(hitsout, name);

            /* Write family header information to output file */
	    /* Now done by call to embHitlistWriteSubset
            if(MAJSTRLEN(hitlist->Class))
                ajFmtPrintF(hitsoutPtr,"CL   %S\n",hitlist->Class);
            if(MAJSTRLEN(hitlist->Fold))
                ajFmtPrintSplit(hitsoutPtr,hitlist->Fold,"XX\nFO   ",75," \t\n\r");
            if(MAJSTRLEN(hitlist->Superfamily))

                ajFmtPrintSplit(hitsoutPtr,hitlist->Superfamily,"XX\nSF   ",75," \t\n\r");
            if(MAJSTRLEN(hitlist->Family))
                ajFmtPrintSplit(hitsoutPtr,hitlist->Family,"XX\nFA   ",75," \t\n\r");
            if(MAJSTRLEN(hitlist->Family))
	       ajFmtPrintF(hitsoutPtr,"XX\nSI   %d\n", hitlist->Sunid_Family);
	       */


            y = 0;
            /* Create array of 1's and 0's */
            for(x=0;x<num_hits;x++)
            {
                score = ((((float)ajIntGet(seq_len, x) / (float)median)) * 100);
                /*printf("thresh = %d\n", thresh);

                  printf("score = %f\n", score);*/
                /*if((score < 0.5) || (score > 2)) */
                if(score < thresh) 
                {
                    /*ajFmtPrint("Acc = %S length = %d\n", hitlist->hits[x]->Acc,
                    ajIntGet(seq_len, x));  */
                    ajIntPut(&seq_ok, x, 0);
                }
            
                else if(score >= thresh)
                {
                    ajIntPut(&seq_ok, x, 1);
                    y++;
                }
            
            }

	    
            /* Write NS field to file */
	    /* Now done by call to embHitlistWriteSubset
            ajFmtPrintF(hitsoutPtr,"XX\nNS   %d\nXX\n",y); */

            /* Go through seq_ok array if element == 1 then   */
            /* write that element of structure to output file */


	    /* Now done by call to embHitlistWriteSubset
            y = 0;
            for(x=0;x<num_hits;x++)
            {
                if(ajIntGet(seq_ok, x) == 1)
                {
                    y++;
                    ajFmtPrintF(hitsoutPtr, "%-5s[%d]\nXX\n", "NN", y);
                    ajFmtPrintF(hitsoutPtr, "%-5s%S\n", "AC", hitlist->hits[x]->Acc);
                    ajFmtPrintF(hitsoutPtr, "XX\n");
                    ajFmtPrintF(hitsoutPtr, "%-5s%S\n", "TY", hitlist->hits[x]->Typeobj);
                    ajFmtPrintF(hitsoutPtr, "XX\n");
                    if(hitlist->hits[x]->Group)
                    {
                        ajFmtPrintF(hitsoutPtr, "%-5s%S\n", "GP", hitlist->hits[x]->Group);
                        ajFmtPrintF(hitsoutPtr, "XX\n");
                    }
                    ajFmtPrintF(hitsoutPtr, "%-5s%d START; %d END;\n", "RA", 
                                hitlist->hits[x]->Start, hitlist->hits[x]->End);
                    ajFmtPrintF(hitsoutPtr, "XX\n");
                    ajSeqWriteXyz(hitsoutPtr, hitlist->hits[x]->Seq, "SQ");
                    ajFmtPrintF(hitsoutPtr, "XX\n");
                }
            
                else
                    continue;
            }


            ajFmtPrintF(hitsoutPtr, "//\n");
	    */

	    embHitlistWriteSubset(hitsoutPtr, hitlist, seq_ok);


            /* Close input and output files and tidy up */
            embHitlistDel(&hitlist);
            hitlist=NULL;
            ajFileClose(&hitsoutPtr);
            ajFileClose(&hitsPtr);
            ajIntDel(&seq_len);
            ajIntDel(&seq_len_sort);
            ajIntDel(&seq_ok);
        }

    
        
        /* Hits file contains either one or zero hits, therefore just copy */
        /* original hits file to new output file                           */

        else
        {
            /* Reset file pointer */
            ajFileSeek(hitsPtr, 0, 0);
            
            /* Read hitlist into structure */
            hitlist = embHitlistRead(hitsPtr);
	            
            /* create output file name and path */
            ajStrFromInt(&name, hitlist->Sunid_Family);

            /* Create output file */
            hitsoutPtr = ajFileNewDirF(hitsout, name);


            /* Write family header information to output file */
            if(MAJSTRLEN(hitlist->Class))
                ajFmtPrintF(hitsoutPtr,"CL   %S\n",hitlist->Class);
            if(MAJSTRLEN(hitlist->Fold))
                ajFmtPrintSplit(hitsoutPtr,hitlist->Fold,"XX\nFO   ",75," \t\n\r");
            if(MAJSTRLEN(hitlist->Superfamily))
                ajFmtPrintSplit(hitsoutPtr,hitlist->Superfamily,"XX\nSF   ",75," \t\n\r");
            if(MAJSTRLEN(hitlist->Family))
                ajFmtPrintSplit(hitsoutPtr,hitlist->Family,"XX\nFA   ",75," \t\n\r");
            if(MAJSTRLEN(hitlist->Family))
                ajFmtPrintF(hitsoutPtr,"XX\nSI   %d\n", hitlist->Sunid_Family);

            /* Write NS field to file */
            ajFmtPrintF(hitsoutPtr,"XX\nNS   %d\nXX\n",num_hits);


            y = 0;
            if(num_hits == 1)
            {
                for(x=0;x<num_hits;x++)

                {
                    y++;
                    ajFmtPrintF(hitsoutPtr, "%-5s[%d]\nXX\n", "NN", y);
                    ajFmtPrintF(hitsoutPtr, "%-5s%S\n", "AC", hitlist->hits[x]->Acc);
                    ajFmtPrintF(hitsoutPtr, "XX\n");
                    ajFmtPrintF(hitsoutPtr, "%-5s%S\n", "TY", hitlist->hits[x]->Typeobj);
                    ajFmtPrintF(hitsoutPtr, "XX\n");
                    if(hitlist->hits[x]->Group)
                    {
                        ajFmtPrintF(hitsoutPtr, "%-5s%S\n", "GP", hitlist->hits[x]->Group);
                        ajFmtPrintF(hitsoutPtr, "XX\n");
                    }
                    ajFmtPrintF(hitsoutPtr, "%-5s%d START; %d END;\n", "RA", 
                                hitlist->hits[x]->Start, hitlist->hits[x]->End);
                    ajFmtPrintF(hitsoutPtr, "XX\n");
                    ajSeqWriteXyz(hitsoutPtr, hitlist->hits[x]->Seq, "SQ");
                    ajFmtPrintF(hitsoutPtr, "XX\n");
                }
            }

            /* Print end of data marker */
            ajFmtPrintF(hitsoutPtr, "//\n");
            
            /* tidy and go on to next file */
            ajFileClose(&hitsPtr);
            ajFileClose(&hitsoutPtr);
            embHitlistDel(&hitlist);
            hitlist=NULL;
        }

	ajStrDel(&temp); 
    }
    
    
    

    /* Tidy up */
    /* Delete strings and list */
    ajListDel(&hitsin);
    ajDirDel(&hitsout);
    ajStrDel(&line);
    ajStrDel(&name);
    ajStrDel(&exec);


    /* Return */
    ajExit();
    return 0;


}










