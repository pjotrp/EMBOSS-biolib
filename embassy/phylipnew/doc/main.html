<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<TITLE>main</TITLE>
<META NAME="description" CONTENT="main">
<META NAME="keywords" CONTENT="PHYLIP", "main", "documentation">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
</HEAD>
<BODY BGCOLOR="#ccffff">
<P>
<DIV ALIGN="CENTER">
<H1>PHYLIP</H1>
<H2>Phylogeny Inference Package</H2>
<P>
<IMG SRC="phylip.gif" ALT="PHYLIP Logo">
<P>
<H3>Version 3.6(alpha3)</H3>
<P>
<H3>July, 2002</H3>
<P>
<H2>by Joseph Felsenstein</H2>
<P>
<BR>
<TABLE>
<TR><TD>
<FONT SIZE="+2">
Department of Genome Sciences<BR>
University of Washington<BR>
Box 357730<BR>
Seattle, WA &nbsp;&nbsp;98195-7730<BR>
USA
</FONT>
</TD></TR>
</TABLE>
<H2>E-mail address: <TT>joe@gs.washington.edu</TT></H2>
</DIV>
<P>
<DIV ALIGN="CENTER">
<A NAME="contents"><HR><P></A>
<H2>Contents of this document</H2></DIV>
<P>
<BR>
<A HREF="#contents">Contents of this document
<BR>
<A HREF="#description">A Brief Description of the Programs</A>
<BR>
<A HREF="#copyright">Copyright Notice for PHYLIP</A>
<BR>
<A HREF="#documentation">The Documentation Files and How to Read Them</A>
<BR>
<A HREF="#programs">What The Programs Do</A>
<BR>
<A HREF="#running">Running the Programs</A>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A word about input files
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Running the programs on a Windows machine
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Running the programs on a Macintosh
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Running the programs on a Unix system
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Running the programs in MSDOS
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Running the programs in background or under control of a command file
<BR>
<A HREF="#inputfiles">Preparing Input Files</A>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Input and output files
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Data file format
<BR>
<A HREF="#menu">The Menu</A>
<BR>
<A HREF="#outputfile">The Output File</A>
<BR>
<A HREF="#treefile">The Tree File</A>
<BR>
<A HREF="#options">The Options and How To Invoke Them</A>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Common options in the menu
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The <TT>U</TT> (User tree) option
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The <TT>G</TT> (Global) option
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The <TT>J</TT> (Jumble) option
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The <TT>O</TT> (Outgroup) option
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The <TT>T</TT> (Threshold) option
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The <TT>M</TT> (Multiple data sets) option
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The <TT>W</TT> (Weights) option
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The option to write out the trees into a tree file
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The (<TT>0</TT>) terminal type option
<BR>
<A HREF="#algorithm">The Algorithm for Constructing Trees</A>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Local Rearrangements
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Global Rearrangements
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Multiple Jumbles
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Saving multiple tied trees
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Strategy for Finding the Best Tree
<BR>
<A HREF="#warning">A Warning on Interpreting Results</A>
<BR>
<A HREF="#speed">Relative Speed of Different Programs and Machines</A>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Relative speed of the different programs
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Speed with different numbers of species
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Relative speed of different machines
<BR>
<A HREF="#comments">General Comments on Adapting the Package to Different Computer Systems</A>
<BR>
<A HREF="#compiling">Compiling the programs</A>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Unix and Linux
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Macintosh PowerMacs
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Compiling with Metrowerks Codewarrior
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;On Windows systems
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Compiling with Microsoft Visual C++
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Compiling with Borland C++
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Compiling with Metrowerks Codewarrior for Windows 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Compiling with Cygnus Gnu C++
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VMS VAX systems
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parallel computers
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Other computer systems
<BR>
<A HREF="#FAQ">Frequently Asked Questions</A>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;How to make it do various things
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Background information needed:
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Questions about distribution and citation:
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Questions about documentation
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Additional Frequently Asked Questions, or: "Why didn't it occur to you to ...
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(Fortunately) obsolete questions
<BR>
<A HREF="#newfeatures">New Features in This Version</A>
<BR>
<A HREF="#future">Coming Attractions, Future Plans</A>
<BR>
<A HREF="#endorsements">Endorsements</A>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;From the pages of <I>Cladistics</I>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;... and in the pages of other journals:
<BR>
<A HREF="#references">References for the Documentation Files</A>
<BR>
<A HREF="#credits">Credits</A>
<BR>
<A HREF="#otherprograms">Other Phylogeny Programs Available Elsewhere</A>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PAUP*
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MacClade
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MEGA
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MOLPHY
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PAML
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TREE-PUZZLE
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DAMBE
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Hennig86
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RnA
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NONA
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TNT
<BR>
<A HREF="#helpme">How You Can Help Me</A>
<BR>
<A HREF="#trouble">In Case of Trouble</A>
<P>
<A NAME="description"><HR><P></A>
<DIV ALIGN="CENTER">
<H2>A Brief Description of the Programs</H2></DIV>
<P>
<TT>PHYLIP</TT>, the Phylogeny Inference Package, is a package of programs for
inferring phylogenies (evolutionary trees).  It has been distributed since
1980, and has over 10,000 registered users, making it the most widely
distributed package of phylogeny programs.  It is available free, from
its web site:
<P>
<DIV ALIGN="CENTER">
<FONT SIZE=+2><A HREF="http://evolution.gs.washington.edu/phylip.html">
<TT>http://evolution.gs.washington.edu/phylip.html</TT></A></FONT>

</DIV>
<P>
<TT>PHYLIP</TT> is available as source code in C, and also as executables for
some common computer systems.  It can infer phylogenies by parsimony,
compatibility, distance matrix methods, and likelihood.  It can also
compute consensus trees, compute distances between trees, draw trees,
resample data sets by bootstrapping or jackknifing, edit trees, and
compute distance matrices.  It can handle data that are nucleotide
sequences, protein sequences, gene frequencies, restriction sites,
restriction fragments, distances, discrete characters, and continuous
characters.
<P>
<BR>
<A NAME="copyright"><HR><P></A>
<DIV ALIGN=CENTER>
<TABLE BORDER=4 WIDTH=80%><TR><TD ALIGN=LEFT>
<DIV ALIGN="CENTER">
<H2>Copyright Notice for PHYLIP</H2></DIV>
<P>
The following copyright notice is intended to cover all source code, all
documentation, and all executable programs of the PHYLIP package.
<P>
&#169; Copyright 1980-2002.  University of Washington and Joseph Felsenstein.  All
rights reserved.  Permission is granted to reproduce, perform, and modify
these programs and documentation files.  Permission is granted to distribute
or provide access to these
programs provided that this copyright notice is not removed, the programs are
not integrated with or called by any product or service that generates
revenue, and that your distribution of these materials program are free.
Any modified
versions of these materials that are distributed or accessible shall indicate
that they are based on these program.  Institutions of higher education are
granted permission to distribute this material to their students and staff
for a fee to recover distribution costs.  Permission requests for any other
distribution of this program should be directed to <TT>license@u.washington.edu</TT>.
<BR>
</TD></TR></TABLE></DIV>

<BR>
<A NAME="documentation"><HR><P></A>
<DIV ALIGN="CENTER">
<H2>The Documentation Files and How to Read Them</H2></DIV>
<P>
<TT>PHYLIP</TT> comes with an extensive set of documentation files.  These
include the main documentation file (this one), which you should read
fairly completely.  In addition there are files for groups of programs,
including ones for the <A HREF="sequence.html">molecular sequence</A>
programs, the <A HREF="distance.html">distance matrix</A>
programs, the
<A HREF="contchar.html">gene frequency and continuous characters</A>
programs, the <A HREF="discrete.html">discrete characters</A> programs,
and the <A HREF="draw.html">tree drawing</A> programs.  Finally,
each program has its own documentation file.  References for the
documentation files are all gathered together in this main documentation
file.  A good strategy is to:
<OL>
<LI>Read this main documentation file.
<LI>Tentatively decide which programs are of interest to you.
<LI>Read the documentation files for the groups of programs that
contain those.
<LI>Read the documentation files for those individual programs.
</OL>
<P>
<A NAME="programs"><HR><P></A>
<DIV ALIGN="CENTER">
<H2>What The Programs Do</H2></DIV>
<P>
Here is a short description of each of the programs.  For more detailed
discussion you should definitely read the documentation file for the
individual program and the documentation file for the group of programs
it is in.  In this list the name of each program is a link which will
take you to the documentation file for that program.  Note that there is no
program in the PHYLIP package called PHYLIP.
<DL>
<DT><STRONG><A HREF="protpars.html">PROTPARS</A></STRONG>
<DD>Estimates phylogenies from protein sequences (input using the
   standard one-letter code for amino acids) using the parsimony method, in
   a variant which counts only those nucleotide changes that change the amino
   acid, on the assumption that silent changes are more easily accomplished.
<DT><STRONG><A HREF="dnapars.html">DNAPARS</A></STRONG>
<DD>Estimates phylogenies by the parsimony method using nucleic acid
   sequences.  Allows use the full IUB ambiguity codes, and estimates 
   ancestral nucleotide states.  Gaps treated as a fifth nucleotide state.
   Can use 0/1 weights, reconstruct ancestral states, and infer branch
   lengths.
<DT><STRONG><A HREF="dnamove.html">DNAMOVE</A></STRONG>
<DD>Interactive construction of phylogenies from nucleic acid
   sequences, with their evaluation by parsimony and compatibility and the
   display of reconstructed ancestral bases.  This can be used to find
   parsimony or compatibility estimates by hand.  
<DT><STRONG><A HREF="dnapenny.html">DNAPENNY</A></STRONG>
<DD>Finds all most parsimonious phylogenies for nucleic acid
   sequences by branch-and-bound search.  This may not be practical (depending
   on the data) for more than 15 species or so.
<DT><STRONG><A HREF="dnacomp.html">DNACOMP</A></STRONG>
<DD>Estimates phylogenies from nucleic acid sequence data using
   the compatibility criterion, which searches for the largest number of sites 
   which could have all states (nucleotides) uniquely evolved on the same 
   tree.  Compatibility is particularly appropriate when sites vary greatly in 
   their rates of evolution, but we do not know in advance which are the less 
   reliable ones.
<DT><STRONG><A HREF="dnainvar.html">DNAINVAR</A></STRONG>
<DD>For nucleic acid sequence data on four species, computes
   Lake's and Cavender's phylogenetic invariants, which test alternative tree
   topologies.  The program also tabulates the frequencies of occurrence of the
   different nucleotide patterns.  Lake's invariants are the method which he
   calls "evolutionary parsimony".
<DT><STRONG><A HREF="dnaml.html">DNAML</A></STRONG>
<DD>Estimates phylogenies from nucleotide sequences by maximum 
   likelihood.  The model employed allows for unequal expected frequencies of 
   the four nucleotides, for unequal rates of transitions and transversions,
   and for different (prespecified) rates of change in different categories of 
   sites, with the program inferring which sites have which rates.  It also
   allows different rates of change at known sites.
<DT><STRONG><A HREF="dnamlk.html">DNAMLK</A></STRONG>
<DD>Same as DNAML but assumes a molecular clock.  The use of the
   two programs together permits a likelihood ratio test of the
   molecular clock hypothesis to be made.
<DT><STRONG><A HREF="proml.html">PROML</A></STRONG>
<DD>Estimates phylogenies from protein amino acid sequences by maximum 
   likelihood.  The PAM or JTTF models can be employed.  The program
   can allow for different (prespecified) rates of change in different
   categories of amino acid positions, with the program inferring which 
   posiitons have which rates.  It also allows different rates of change
   at known sites.
<DT><STRONG><A HREF="promlk.html">PROMLK</A></STRONG>
<DD>Same as PROML but assumes a molecular clock.  The use of the
   two programs together permits a likelihood ratio test of the
   molecular clock hypothesis to be made.
<DT><STRONG><A HREF="dnadist.html">DNADIST</A></STRONG>
<DD>Computes four different distances between species from nucleic
   acid sequences.  The distances can then be used in the distance matrix
   programs.  The distances are the Jukes-Cantor formula, one based on Kimura's
   2-parameter method, Jin and Nei's distance which allows for rate variation
   from site to site, and a maximum likelihood method using the model employed 
   in DNAML.  The latter method of computing distances can be very slow.
<DT><STRONG><A HREF="protdist.html">PROTDIST</A></STRONG>
<DD>Computes a distance measure for protein sequences, using
   maximum likelihood estimates based on the Dayhoff PAM matrix, Kimura's 1983
   approximation to it, or a model based on the genetic code plus a
   constraint on changing to a different category of amino acid.  Rate
   variation from site to site is also allowed.  The
   distances can be used in the distance matrix programs.
<DT><STRONG><A HREF="restdist.html">RESTDIST</A></STRONG>
<DD>Distances calculated from restriction sites data or
   restriction fragments data.  The restriction sites option is the one to
   use to also make distances for RAPDs or AFLPs.
<DT><STRONG><A HREF="restml.html">RESTML</A></STRONG>
<DD>Estimation of phylogenies by maximum likelihood using
   restriction sites data (not restriction fragments but presence/absence of
   individual sites).  It employs the Jukes-Cantor symmetrical model of
   nucleotide change, which does not allow for differences of rate between
   transitions and transversions.  This program is <I>very</I> slow.
<DT><STRONG><A HREF="seqboot.html">SEQBOOT</A></STRONG>
<DD>Reads in a data set, and produces multiple data sets from
   it by bootstrap resampling.  Since most programs in the current version of
   the package allow processing of multiple data sets, this can be used
   together with the consensus tree program CONSENSE to do bootstrap (or
   delete-half-jackknife) analyses with most of the methods in this package.
   This program also allows the Archie/Faith technique of permutation of
   species within characters.  It can also rewrite a data set to convert
   it from between the PHYLIP Interleaved and Sequential forms, and into
   a preliminary version of a new XML sequence alignment format
   which is under development.
<DT><STRONG><A HREF="fitch.html">FITCH</A></STRONG>
<DD>Estimates phylogenies from distance matrix data under the
   "additive tree model" according to which the distances are expected to
   equal the sums of branch lengths between the species.  Uses the
   Fitch-Margoliash criterion and some related least squares criteria.  Does
   not assume an evolutionary clock.  This program will be useful with
   distances computed from molecular sequences, restriction sites or fragments
   distances, with DNA hybridization measurements, and with genetic distances 
   computed from gene frequencies.
<DT><STRONG><A HREF="kitsch.html">KITSCH</A></STRONG>
<DD>Estimates phylogenies from distance matrix data under the 
   "ultrametric" model which is the same as the additive tree model except 
   that an evolutionary clock is assumed.  The Fitch-Margoliash criterion and 
   other least squares criteria are assumed.  This program will be useful with 
   distances computed from molecular sequences, restriction sites or
   fragments distances, with distances from DNA hybridization measurements, 
   and with genetic distances computed from gene frequencies. 
<DT><STRONG><A HREF="neighbor.html">NEIGHBOR</A></STRONG>
<DD>An implementation by Mary Kuhner and John Yamato of Saitou and
   Nei's "Neighbor Joining Method," and of the UPGMA (Average Linkage
   clustering) method.  Neighbor Joining is a distance matrix method producing
   an unrooted tree without the assumption of a clock.  UPGMA does assume a
   clock.  The branch lengths are not optimized by the least squares criterion
   but the methods are very fast and thus can handle much larger data sets.
<DT><STRONG><A HREF="contml.html">CONTML</A></STRONG>
<DD>Estimates phylogenies from gene frequency data by maximum
   likelihood under a model in which all divergence is due to genetic drift in
   the absence of new mutations.  Does not assume a molecular clock.  An 
   alternative method of analyzing this data is to compute Nei's genetic 
   distance and use one of the distance matrix programs.
   This program can also do maximum likelihoodn analysis of continuous
   charactersn that evolve by a Brownian Motion model, but it assumes that
   the characters evolve at equal rates and in an uncorrelated fashion, so
   that it does not take into account the usual correlations of characters.
<DT><STRONG><A HREF="gendist.html">GENDIST</A></STRONG>
<DD>Computes one of three different genetic distance formulas
   from gene frequency data.  The formulas are Nei's genetic distance, the
   Cavalli-Sforza chord measure, and the genetic distance of Reynolds et. al.
   The former is appropriate for data in which new mutations occur in an
   infinite isoalleles neutral mutation model, the latter two for a model
   without mutation and with pure genetic drift.  The distances are written to
   a file in a format appropriate for input to the distance matrix programs.
<DT><STRONG><A HREF="contrast.html">CONTRAST</A></STRONG>
<DD>Reads a tree from a tree file, and a data set with continuous
   characters data, and produces the independent contrasts for those
   characters, for use in any multivariate statistics package.  Will also
   produce covariances, regressions and correlations between characters for
   those contrasts.  Can also correct for within-species sampling variation
   when individual phenotypes are available within a population.
<DT><STRONG><A HREF="pars.html">PARS</A></STRONG>
<DD>Multistate discrete-characters parsimony method.   Up to 8 states
  (as well as "<TT>?</TT>") are allowed.  Cannot do Camin-Sokal or Dollo Parsimony.
  Can reconstruct ancestral states, use character weights, and infer branch
  lengths.
<DT><STRONG><A HREF="mix.html">MIX</A></STRONG>
<DD>Estimates phylogenies by some parsimony methods for discrete
   character data with two states (0 and 1).  Allows use of the
   Wagner parsimony method, the Camin-Sokal parsimony method, or arbitrary
   mixtures of these.  Also reconstructs ancestral states and allows weighting
   of characters (does not infer branch lengths).
<DT><STRONG><A HREF="move.html">MOVE</A></STRONG>
<DD>Interactive construction of phylogenies from discrete character
   data with two states (0 and 1).  Evaluates parsimony and compatibility
   criteria for those phylogenies and displays reconstructed states throughout
   the tree.  This can be used to find parsimony or compatibility estimates by 
   hand. 
<DT><STRONG><A HREF="penny.html">PENNY</A></STRONG>
<DD>Finds all most parsimonious phylogenies for discrete-character
   data with two states, for the Wagner, Camin-Sokal, and mixed parsimony
   criteria using the branch-and-bound method of exact search.  May be
   impractical (depending on the data) for more than 10-11 species. 
<DT><STRONG><A HREF="dollop.html">DOLLOP</A></STRONG>
<DD>Estimates phylogenies by the Dollo or polymorphism parsimony
   criteria for discrete character data with two states (0 and 1).  Also
   reconstructs ancestral states and allows weighting of characters.  Dollo
   parsimony is particularly appropriate for restriction sites data; with
   ancestor states specified as unknown it may be appropriate for restriction
   fragments data.
<DT><STRONG><A HREF="dolmove.html">DOLMOVE</A></STRONG>
<DD>Interactive construction of phylogenies from discrete
   character data with two states (0 and 1) using the Dollo or polymorphism
   parsimony criteria.  Evaluates parsimony and compatibility criteria for
   those phylogenies and displays reconstructed states throughout the tree. 
   This can be used to find parsimony or compatibility estimates by hand. 
<DT><STRONG><A HREF="dolpenny.html">DOLPENNY</A></STRONG>
<DD>Finds all most parsimonious phylogenies for
    discrete-character data with two states, for the Dollo or polymorphism
   parsimony criteria using the branch-and-bound method of exact search.  May
   be impractical (depending on the data) for more than 10-11 species. 
<DT><STRONG><A HREF="clique.html">CLIQUE</A></STRONG>
<DD>Finds the largest clique of mutually compatible characters, and
   the phylogeny which they recommend, for discrete character data with two 
   states.  The largest clique (or all cliques within a given size range of 
   the largest one) are found by a very fast branch and bound search method.  
   The method does not allow for missing data.  For such cases the <TT>T</TT>
   (Threshold) option of PARS or MIX may be a useful alternative. 
   Compatibility methods are particular useful when some characters are of
   poor quality and the rest of good quality, but when it is not known in
   advance which ones are which.
<DT><STRONG><A HREF="factor.html">FACTOR</A></STRONG>
<DD>Takes discrete multistate data with character state trees and 
   produces the corresponding data set with two states (0 and 1).  Written by 
   Christopher Meacham.  This program was formerly used to accomodate
   multistate characters in MIX, but this is less necessary now that PARS is
   available.
<DT><STRONG><A HREF="drawgram.html">DRAWGRAM</A></STRONG>
<DD>Plots rooted phylogenies, cladograms, and phenograms in a
   wide variety of user-controllable formats.  The program is interactive and
   allows previewing of the tree on PC or Macintosh graphics screens, 
   and Tektronix or Digital graphics terminals.  Final output can be 
   to a file formatted for one of the drawing programs, on
   a laser printer (such as Postscript or PCL-compatible printers),
   on graphics screens or terminals, on pen plotters (Hewlett-Packard or
   Houston Instruments) or on dot matrix printers capable of graphics
   (Epson, Okidata, Imagewriter, or Toshiba).
<DT><STRONG><A HREF="drawtree.html">DRAWTREE</A></STRONG>
<DD>Similar to DRAWGRAM but plots unrooted phylogenies.
<DT><STRONG><A HREF="treedist.html">TREEDIST</A></STRONG>
<DD>Computes the Robinson-Foulds symmetric difference distance
   between trees, which allows for differences in tree topology (but does not
   use branch lengths).
<DT><STRONG><A HREF="consense.html">CONSENSE</A></STRONG>
<DD>Computes consensus trees by the majority-rule consensus tree 
   method, which also allows one to easily find the strict consensus tree.  
   Is not able to compute the Adams consensus tree.  Trees are input in a tree
   file in standard nested-parenthesis notation, which is produced by many of
   the tree estimation programs in the package.  This program can be used as
   the final step in doing bootstrap analyses for many of the methods in the
   package.
<DT><STRONG><A HREF="retree.html">RETREE</A></STRONG>
<DD>Reads in a tree (with branch lengths if necessary) and allows
   you to reroot the tree, to flip branches, to change species names and
   branch lengths, and then write the result out.  Can be used to convert
   between rooted and unrooted trees, and to write the tree into a
   preliminary version of a new XML tree file format which is under
   development.
</DL>
<P>
<A NAME="running"><HR><P></A>
<DIV ALIGN="CENTER">
<H2>Running the Programs</H2></DIV>
<P>
This section assumes that you have obtained PHYLIP as compiled executables
(for Windows, Macintosh, or DOS), or have obtained the source code
and compiled it yourself (for Linux, Unix, or OpenVMS).   For machines for
which compiled executables are available, there will usually be no need for
you to have a compiler or compile the programs yourself.  This section
describes how to run the programs.  Later in this document we will
discuss how to download and install PHYLIP (in case you are somehow
reading this without yet having done that).  Normally you will only read
this document after downloading and installing PHYLIP.
<P>
<H3>A word about input files.</H3>
<P>
For all of these types of machines, it is
important to have the input files for the programs (typically data files)
prepared in advance.  They can be prepared in any editor, but it is important
that they be saved in Text Only ("flat ASCII") format, not in the format that
word processors such as Microsoft Word want to write.  It is up to you to read
the PHYLIP documentation files which describe the files formats that are
needed.  There is a partial description in the next section of this document.
The input files can also be obtained by running a program that
produces output files in PHYLIP format (some of these programs do, and so do
programs by others such as sequence alignment programs such as ClustalW and
sequence format conversion programs such as Readseq).   There is <I>not</I> any
input file editor available in any program in PHYLIP (you should <I>not</I>
simply start running one of the programs and then expect to click a mouse
somewhere to start creating a data file).  
<P>
When they start running, the programs look first for input files with
particular names (such as <TT>infile</TT>, <TT>treefile</TT>,  <TT>intree</TT>, or <TT>fontfile</TT>).
Exactly which file names they look for varies a bit from program to program,
and you should read the documentation file for the particular program to
find out.  If you have files with those names the programs will use them
and not ask you for the file name.  If they do not find files of those
names, the programs will say that they cannot find a file of that name, and
ask you to type in the file name.
For example, if DnaML looks
for the file <TT>infile</TT> and does not find one of that name,
it prints the message:
<P>
<TABLE><TR><TD BGCOLOR=white>
<TT>dnaml: can't find input file "infile"<BR>
Please enter a new file name></TT>
</TD></TR></TABLE>
<P><I>This does not mean that an error
has occurred.</I>  All you need to do is to type in the name of the file.
<P>
The program looks for the input files in the same directory that the
program is in (a directory is the same thing as a "folder").  In Windows, Linux, Unix, or MSDOS, if you are asked for the
file name you can type in the path to the file, as part of the name (thus,
if the file is in the directory above the current one, you can type in
a file name such as <TT>../myfile.dna</TT>).   If you do not know what a
"directory" is, or what "above" means, then you are a member of the new
generation who just clicks the mouse and assumes that a list of file names
will magically appear.  (Typically members of this generation have no idea
where the files are on their system, and accumulate enormous amounts of
unnecessary clutter in their file systems.)  In this case you should ask
someone to explain directories to you.
<P>
<H3>Running the programs on a Windows machine.</H3>
<P>
Double-click on the icon for
the program.  A window should open with a menu in it.  Further dialog with the
program occurs
by typing on the keyboard in response to what you see in the window.  The
programs can be interrupted either by typing Control-C (which means to
press down on the <TT>Ctrl</TT> key while typing the letter <TT>C</TT>), or by using
the mouse to open the <TT>File</TT> menu in the upper-left corner of the program's
window area and then select <TT>Quit</TT>.  Other than this, most PHYLIP programs
make no use of the mouse.  The tree-drawing programs Drawtree and Drawgram
do allow use of the mouse to select some options.
<P>
<H3>Running the programs on a Macintosh.</H3>
<P>
Double-click on the icon for
the program.  A window should open.  Further dialog with the program occurs
by typing on the keyboard in response to what you see in the window.  The
programs can be interrupted by using
the mouse to open the <TT>File</TT> menu in the upper-left corner of the program's
window area and then select <TT>Quit</TT>.  Alternatively, you can use the
Command-Q key combination.
<P>
When you use Quit, the program will ask you whether you want to save
a file whose name is the program name (often followed by <TT>.out</TT> -- for
example, if you are using DNAML it will ask you if you want to save file
<TT>Dnaml.out</TT>.  This file is simply a record of everything that
displayed on the program window, and you usually will not want to save it.
Pressing the <TT>Enter</TT> key or selecting the Do Not Save button with
the mouse will keep this from being saved.
<P>
If you encounter memory limitations on a Macintosh, and determine that
this is not due to a problem with the format of the input file, as it
often will be, you may be able to solve it by raising the limits of the
stack and heap sizes of the program.  To do this click on the program
and then select <TT>Get Info</TT> from the Finder <TT>File</TT> menu.
This will open a window which can be made to show the memory limits
of the program.  These can be changed by selecting them and typing in
larger numbers.  This may relieve nagging memory problems.  If it does
not, consult your local documentation and suspect problems with your
input file format.
<P>
<H3>Running the programs on a Unix system.</H3>
<P>
Type the name of the program
in lower-case letters (such as <TT>dnaml</TT>).  To interrupt the program while
it is running, type Control-C (which means to press down on the <TT>Ctrl</TT> key
while typing the letter <TT>C</TT>).
<P>
<H3>Running the programs in MSDOS.</H3>
<P>
Type the name of the program
in lower-case letters (such as <TT>dnaml</TT>).  To interrupt the program while
it is running, type Control-C (which means to press down on the <TT>Ctrl</TT> key
while typing the letter <TT>C</TT>).  
<P>
<H3>Running the programs in background or under control of a command file</H3>
<P>
In running the programs, you may sometimes want to put them in background
so you can proceed with other work.  On systems with a windowing environment
they can be put in their own window, and commands like the Unix and Linux
<TT>nice</TT> command used to make
them have lower priority so that they do not interfere with interactive
applications in other windows.  This part of the discussion will
assume either a Windows system or a Unix or Linux system.  I will
note when the commands work on one of these systems but not the other.
Running jobs in background on Macintosh systems is an arcane art into whose
mysteries I have not been initiated (or perhaps no one has been initiated).
<P>
If there is no windowing
environment, on a Unix or Linux system you will want to use an
ampersand (<TT>&amp;</TT>) after the command file name when invoking it to put the
job in the background.  You will have to put all the responses to the
interactive menu of the program into a file and tell the background job
to take its input from that file.
On Windows systems there is no <TT>&amp;</TT> or <TT>nice</TT> command
but input and output redirection and command files work fine, with the sole
difference that the a file of commands must have a name ending in
<TT>.BAT</TT>, such as <TT>FOOFILE.BAT</TT>.
<P>
For example: suppose you want to run DNAPARS in a background, taking its
input data from a file called <TT>sequences.dat</TT>, putting its interactive
output to file called <TT>screenout</TT>, and using a file called <TT>input</TT> as
the place to store the interactive input.  The file <TT>input</TT> need only
contain two lines:
<P>
<TABLE><TR><TD bgcolor=white>
<PRE>
sequences.dat
Y
</PRE>
</TD></TR></TABLE>
<P>
which is what you would have typed to run the program interactively, in
response to the program's request for an input file name if it did not
find a file named <TT>infile</TT>, in in response the the menu.
<P>
To run the program in background, in Unix or Linux you would simply give the command:
<P>
<TT>dnapars &lt; input &gt; screenout &amp;
</TT>
<P>
These run the program with input responses coming from <TT>input</TT> and
interactive output being put into file <TT>screenout</TT>.  The usual output
file and tree file will also be created by this run (keep that in mind
as if you run any other PHYLIP program from the same directory while
this one is running in background you may overwrite the output file from
one program with that from the other!).
<P>
If you wanted to give the program lower priority, so that it would
not interfere with other work, and you have Berkeley Unix type job control
facilities in your Unix or Linux (and you usually do), you can use the
<TT>nice</TT> command:
<P>
<TT>nice +10 dnapars &lt; input &gt; screenout &amp;
</TT>
<P>
which lowers the priority of the run.  To also time the run and put the
timing at the end of <TT>screenout</TT>, you can do this:
<P>
<TT>nice +10 ( time dnapars &lt; input ) &gt;&amp; screenout &amp;
</TT>
<P>
which I will not attempt to explain.
<P>
On Unix or Linux systems
you may also want to explore putting the interactive output into the
null file <TT>/dev/null</TT> so as to not be bothered with it (but then you
cannot look at it to see why something went wrong).  If you have problems
with creating output files that are too large, you may want to
explore carefully the turning off of options in the programs you run.
<P>
If you are doing several runs in one, as for example when you do a
bootstrap analysis using SEQBOOT, DNAPARS (say), and CONSENSE, you
can use an editor to create a "command file" with these commands:
<P>
<TABLE><TR><TD bgcolor=white>
<PRE>
seqboot < input1 > screenout
mv outfile infile
dnapars < input2 >> screenout
mv outtree intree
consense < input3 >> screenout
</PRE>
</TD></TR></TABLE>
<P>
This is the Unix or Linux version -- in the MSDOS version, the renaming
of files and the appending of output to the file <TT>screenout</TT> is
handled differently.
<P>
On Unix or Linux the command file might be named something like
<TT>foofile</TT>, and on Windows systems might be named <TT>foofile.bat</TT>.
<P>
On Unix or Linux the command file must be given
execute permission by using the command  <TT>chmod +x foofile</TT> followed
by the command <TT>rehash</TT>.  The job that <TT>foofile</TT> describes
can be run in background on Unix or Linux by giving the command
<P>
<TT>foofile &amp;</TT>
<P>
On Windows systems it can be run by
clicking on the icon of the command file.  Its icon will have a little gear
symbol.
<P>
Note that you must also have the interactive input
commands for SEQBOOT (including the random number seed), DNAPARS, and
CONSENSE in the separate files <TT>input1</TT>, <TT>input2</TT>, and <TT>input3</TT>.
Note that when PHYLIP programs attempt to open a new output file (such as
<TT>outfile</TT>, <TT>outtree</TT>, or <TT>plotfile</TT>, if they see
a file of that name already in existence they will ask you if you want to
overwrite it, and offer alternatives including writing to another file,
appending information to that file, or quitting the program without writing to
the file.  This means that in writing batch files it is important to know
whether there will be a prompt of this sort.  You must know in advance
whether the file will exist.  You may want to put in your batch file a
command that tests for the existence of a pre-existing output file and
if so, removes it.  You might even want to put in a command that creates a
file of that name, so that you can be sure it is there!  Either way,
you will then know whether to put into your file of keyboard responses the
proper response to the inquiry about overwriting that output file.
<P>
<A NAME="inputfiles"><HR><P></A>
<DIV ALIGN="CENTER">
<H2>Preparing Input Files</H2></DIV>
<P>
The input files for PHYLIP programs must be prepared separately - there is
no data editor within PHYLIP.  You can use a word processor (or text
editor) to prepare them yourself, or you can use a program that produces
a PHYLIP-format output.  Sequence alignment programs such as ClustalW
commonly have an option to produce PHYLIP files as output, and some
other phylogeny programs, such as MacClade and TreeView, are capable of
producing a PHYLIP-format file.
<P>
The format of the input files is discussed below, and you should also
read the other PHYLIP documentation relevant to the particular type of
data that you are using, and the particular programs you want to run, as
there will be more details there.
<P>
It is very important that the input files be in "Text Only" or "flat
ASCII" format.  This means that they contain only printable ASCII/ISO
characters, and not any unprintable characters.  Many word processors such
as Microsoft Word save their files in a format that contains unprintable
characters, unless you tell them not to.  For Microsoft Word you can
select <TT>Save As</TT> from its <TT>File</TT> menu, and choose <TT>Text Only</TT>
as the file format.  This can also be done in WordPad utility in Windows .
Other word processors will have equivalent
options.  Text editors such as the <TT>vi</TT> and <TT>emacs</TT> editors on
Unix and Linux, Windows Notepad, the <TT>SimpleText</TT> editor in MacOS, or the <TT>pico</TT>
editor that comes with the <TT>pine</TT>
mailer program, produce their files in Text Only format and should not
cause any trouble.
<P>
<H3>Input and output files</H3>
<P>
For most of the PHYLIP programs, information comes from a series of
input files, and ends up in a series of output files:
<P>
<DIV ALIGN="CENTER">
<TABLE>
<TR><TD>
<PRE>
                   -------------------
                  |                   |
infile ---------> |                   |
                  |                   |
intree ---------> |                   | -----------> outfile
                  |                   |
weights --------> |      program      | -----------> outtree
                  |                   |
categories -----> |                   | -----------> plotfile
                  |                   |
fonftile -------> |                   |
                  |                   |
                   -------------------
</PRE>
</TD></TR>
</TABLE>
</DIV><P></P>

<P>
The programs interact with the user by presenting a menu.  Aside from the
user's choices from the menu, they read
all other input from files.  These files have default names.  The program
will try to find a file of that name - if it does not, it will ask the
user to supply the name of that file.
Input data such as DNA sequences
comes from a file whose default name is <TT>infile</TT>.  If the user
supplies a tree, this is in a file whose default name is <TT>intree</TT>.
Values of weights for the characters are in <TT>weights</TT>, and the
tree plotting program need some digitized fonts which are supplied in
<TT>fontfile</TT> (all these are default names).
<P>
For example, if DnaML looks
for the file <TT>infile</TT> and does not find one of that name,
it prints the message:
<P>
<TABLE><TR><TD BGCOLOR=white>
<TT>dnaml: can't find input file "infile"<BR>
Please enter a new file name></TT>
</TD></TR></TABLE>
<P>
This simply means that it wants you to type in the name of the
input file.
<P>
Two programs in the package works differently according to an older ("Old
Style") system.  These are <TT>CLIQUE</TT> and <TT>FACTOR</TT>.   The information on ancestral
states is supplied in the data file whose
default name is <TT>infile</TT>, and for <TT>FACTOR</TT> the Factors
information is written into the output file rather than being put into a
separate file called <TT>factors</TT>.   See the <A HREF="clique.html">documentation
page for <TT>CLIQUE</TT></A>
and the <A HREF="factor.html">documentation page for FACTOR</A>
for information on these differences.  By the time of the final 3.6
release we hope to have these last Old Style programs converted to the new
system.
<P>
<H3>Data file format</H3>
<P>
I have tried to adhere to a rather stereotyped input and output
format.  For the parsimony, compatibility and maximum likelihood programs, 
excluding the distance matrix methods, the simplest version of the input
data file looks something like this:
<P>
<TABLE><TR><TD BGCOLOR=white>
<PRE>
   6   13
Archaeopt CGATGCTTAC CGC
HesperorniCGTTACTCGT TGT
BaluchitheTAATGTTAAT TGT
B. virginiTAATGTTCGT TGT
BrontosaurCAAAACCCAT CAT
B.subtilisGGCAGCCAAT CAC
</TD></TR></TABLE>
</PRE>
<P>
The first line of the input file contains the number of species and the
number of characters (in this case sites).  These are in free format, separated
by blanks.  The information for each species follows, starting with a
ten-character species name (which can include blanks and some punctuation
marks), and continuing with the characters for that species.  The name should
be on the same line as the first character of the data for that species.
(I will use the term "species" for the tips of the trees, recognizing
that in some cases these will actually be populations or individual gene
sequences).
<P>
The name should be ten characters in length, filled out to the full
ten characters by blanks if shorter.  Any printable ASCII/ISO character is
allowed in the name, except for parentheses ("<TT>(</TT>" and "<TT>)</TT>"), square
brackets ("<TT>[</TT>" and "<TT>]</TT>"), colon ("<TT>:</TT>"), semicolon ("<TT>;</TT>") and comma ("<TT>,</TT>").
If you forget to extend the names to ten characters in length by blanks,
the program will get out of synchronization with the contents of the data
file, and an error message will result.
<P>
In the
discrete-character programs, DNA sequence programs and protein sequence
programs the characters are each a
single letter or digit, sometimes separated by blanks.  In
the continuous-characters programs they are real numbers with decimal points,
separated by blanks:
<P>
<TT>Latimeria  2.03  3.457  100.2  0.0  -3.7</TT>
<P>
The conventions about continuing the data beyond one line per species are
different between the molecular sequence programs and the others.  The 
molecular sequence programs can take the data in "aligned" or "interleaved"
format, in which we first have some lines giving the first part of each of the
sequences, then some
lines giving the next part of each, and so on.  Thus the sequences might
look like this:
<P>
<TABLE><TR><TD BGCOLOR=white>
<PRE>
    6   39
Archaeopt CGATGCTTAC CGCCGATGCT
HesperorniCGTTACTCGT TGTCGTTACT
BaluchitheTAATGTTAAT TGTTAATGTT
B. virginiTAATGTTCGT TGTTAATGTT
BrontosaurCAAAACCCAT CATCAAAACC
B.subtilisGGCAGCCAAT CACGGCAGCC

TACCGCCGAT GCTTACCGC
CGTTGTCGTT ACTCGTTGT
AATTGTTAAT GTTAATTGT
CGTTGTTAAT GTTCGTTGT
CATCATCAAA ACCCATCAT
AATCACGGCA GCCAATCAC
</PRE>
</TD></TR></TABLE>
<P>
Note that in these sequences we have a blank every
ten sites to make them easier to read: any such blanks are allowed.  The blank
line which separates the two groups of lines (the ones
containing sites 1-20 and ones containing sites 21-39) may or may not
be present, but if it is, it should be a line of zero length and not contain
any extra blank
characters (this is because of a limitation of the current versions
of the programs).  It is important that the number of sites in each
group be the same for all species (i.e., it will not be possible to run
the programs successfully if the first species line contains 20 bases, but
the first line for the second species contains 21 bases).
<P>
Alternatively, an option can be selected in the menu to take the data in
"sequential" format, with all of the data for the first species,
then all of the characters for the next species, and so on.  This is also
the way that the discrete characters programs and the gene frequencies
and quantitative characters programs want to read the data.  They do not
allow the interleaved format.
<P>
In the sequential format, the character data can run on to a new line at any
time (except in the middle of a species name or, in the case of continuous
character and distance matrix programs where you cannot go to a new line in
the middle of a real number).  Thus it is legal to have:
<P>
<TT>Archaeopt 001100
<BR>
1101
<BR>
</TT>
<P>
or even:
<P>
<TT>Archaeopt 
<BR>
0011001101
<BR>
</TT>

<P>
though note that the <I>full</I> ten characters of the species name <I>must</I>
then be present: in the above case there must be a blank after the "t".  In all
cases it is possible to put internal blanks between any of the character
values, so that
<P>
<TT>Archaeopt 0011001101 0111011100
</TT>
<P>
is allowed.
<P>
Note that you can convert molecular sequence data between the interleaved
and the sequential data formats by using the Rewrite option of the D
menu item in SEQBOOT.
<P>
If you make an error in the format of the input file, the programs can
sometimes detect that
they have been fed an illegal character or illegal numerical value and issue
an error message such as <TT>BAD CHARACTER STATE:</TT>, often printing out the 
bad value, and sometimes the number of the species and character in which it
occurred.  The program will then stop shortly after.  One of the things which
can lead to a bad value is the omission of something earlier in the file, or
the insertion of something superfluous, which cause the reading of the file to
get out of synchronization.  The program then starts reading things it
didn't expect, and concludes that they are in error.  So if you see this error
message, you may also want
to look for the earlier problem that may have led to the program becoming
confused about what it is reading.
<P>
Some options are described below, but you should also read the documentation
for the groups of the programs and for the individual programs.
<BR>
<P>
<A NAME="menu"><HR><P></A>
<H3>The Menu</H3>
<P>
The menu is straightforward.  It typically looks like this (this one is for
DNAPARS):
<P>
<TABLE><TR><TD BGCOLOR=white>
<PRE>
DNA parsimony algorithm, version 3.6

Setting for this run:
  U                 Search for best tree?  Yes
  S                        Search option?  More thorough search
  V              Number of trees to save?  100
  J   Randomize input order of sequences?  No. Use input order
  O                        Outgroup root?  No, use as outgroup species  1
  T              Use Threshold parsimony?  No, use ordinary parsimony
  N           Use Transversion parsimony?  No, count all steps
  W                       Sites weighted?  No
  M           Analyze multiple data sets?  No
  I          Input sequences interleaved?  Yes
  0   Terminal type (IBM PC, ANSI, none)?  (none)
  1    Print out the data at start of run  No
  2  Print indications of progress of run  Yes
  3                        Print out tree  Yes
  4          Print out steps in each site  No
  5  Print sequences at all nodes of tree  No
  6       Write out trees onto tree file?  Yes

  Y to accept these or type the letter for one to change
</PRE>
</TD></TR></TABLE>
<P>
If you want to accept the default settings (they are shown in the above case)
you can simply type <TT>Y</TT> followed by pressing on the <TT>Enter</TT> key.
If you want to change any of the options, you should type the letter
shown to the left of its entry in the menu.  For example, to set a threshold
type <TT>T</TT>.  Lower-case letters will also work.  For many of the options
the program will ask for supplementary information, such as the value of
the threshold. 
<P>
Note the <TT>Terminal type</TT> entry, which you will find on all menus.  It
allows you to specify which type of terminal your screen is.  The options
are an IBM PC screen, an ANSI standard terminal, or <TT>none</TT>.
Choosing zero (<TT>0</TT>) toggles
among these three options in cyclical order, changing each time the <TT>0</TT>
option is chosen.  If one of them is right for your terminal the screen will be
cleared before the menu is displayed.  If none works, the <TT>none</TT> option
should probably be chosen.  The programs should start with a terminal option
appropriate for your computer, but if they do not, you can change the
terminal type manually.  This is particularly important in program RETREE
where a tree is displayed on the screen - if the terminal type is set to the
wrong value, the tree can look very strange.
<P>
The other numbered options control which information the program will
display on your screen or on the output files.  The option to <TT>Print
indications of progress of run</TT> will show information such as the names of
the species as they are successively added to the tree, and the
progress of rearrangements.  You will usually want to see these as
reassurance that the program is running and to help you estimate how long
it will take.  But if you are running the program "in background" as can be
done on multitasking and multiuser systems, and do not have the
program running in its own window, you may want to turn this option off so
that it does not disturb your use of the computer while the program is
running.
<P>
<A NAME="outputfile"><HR><P></A>
<H2>The Output File</H2>
<BR>
<P>
Most of the programs write their output onto a file called (usually) <TT>outfile</TT>, and a representation of the trees found onto a file called
<TT>outtree</TT>.
<P>
The exact contents of the output file vary from program to program and also
depend on which menu options you have selected.  For many programs, if you
select all possible output information, the output will consist of
(1) the name of the program and its
version number, (2) some of the input information printed out, and (3) a series of
phylogenies, some with associated information indicating how much change
there was in each character or on each part of the tree.  A typical rooted tree
looks like this:
<P>
<TABLE><TR><TD BGCOLOR=white>
<PRE>
                                     +-------------------Gibbon
        +----------------------------2
        !                            !      +------------------Orang
        !                            +------4
        !                                   !  +---------Gorilla
  +-----3                                   +--6
  !     !                                      !    +---------Chimp
  !     !                                      +----5
--1     !                                           +-----Human
  !     !
  !     +-----------------------------------------------Mouse
  !
  +------------------------------------------------Bovine
</PRE>
</TD></TR></TABLE>
<P>
The interpretation of the tree is fairly straightforward: it "grows"
from left to right.  The numbers at the forks are arbitrary and are used (if
present) merely to identify the forks.  For many of the programs the tree 
produced is unrooted.   Rooted and unrooted trees are printed in nearly the
same form, but the unrooted ones are accompanied by the
warning message:
<P>
<TT>   remember: this is an unrooted tree!
</TT>
<P>
to indicate that this is an unrooted tree and to warn against
taking the position of its root too seriously.  Mathematicians still call
an unrooted tree a tree, though some systematists unfortunately use the term
"network" for an unrooted tree.  This conflicts with standard mathematical
usage, which reserves the name "network" for a completely different kind of
graph).  The root of this tree could be anywhere, say on the line leading
immediately to <TT>Mouse</TT>.  As an exercise,
see if you can tell whether the following tree is or is not a different
one from the above:
<P>
<TABLE><TR><TD BGCOLOR=white>
<PRE>
             +-----------------------------------------------Mouse
             !
   +---------4                                   +------------------Orang
   !         !                            +------3
   !         !                            !      !       +---------Chimp
---6         +----------------------------1      !  +----2
   !                                      !      +--5    +-----Human
   !                                      !         !
   !                                      !         +---------Gorilla
   !                                      !
   !                                      +-------------------Gibbon
   !
   +-------------------------------------------Bovine

   remember: this is an unrooted tree!
</PRE>
</TD></TR></TABLE>
<P>
(it is <I>not</I> different).  It is <I>important</I> also to realize that the
lengths of the segments of the printed tree may not be significant: some
may actually represent branches of zero length, in the sense that there is no
evidence that 
those branches are nonzero in length.  Some of the diagrams of trees attempt
to print branches approximately proportional to estimated
branch lengths, while in others the lengths are purely conventional and
are presented just to make the topology visible.  You will have to look closely 
at the documentation that accompanies each program to see what it presents
and what is known about the lengths of the branches on the tree.  The above
tree attempts to represent branch lengths approximately in the diagram.  But
even in those cases, some of the smaller branches are likely to be
artificially lengthened to make the tree topology clearer.  Here is what
a tree from DNAPARS looks like, when no attempt is made to make the
lengths of branches in the diagram proportional to estimated branch
lengths:
<P>
<TABLE><TR><TD BGCOLOR=white>
<PRE>
                 +--Human
              +--5
           +--4  +--Chimp
           !  !
        +--3  +-----Gorilla
        !  !
     +--2  +--------Orang
     !  !
  +--1  +-----------Gibbon
  !  !
--6  +--------------Mouse
  !
  +-----------------Bovine

  remember: this is an unrooted tree!
</PRE>
</TD></TR></TABLE>
<P>
When a tree has branch lengths, it will be accompanied by a table showing
for each branch the numbers (or names) of the nodes at each end of the
branch, and the length of that branch.  For the first tree shown above,
the corresponding table is:
<P>
<TABLE><TR><TD BGCOLOR=white>
<PRE>
 Between        And            Length      Approx. Confidence Limits
 -------        ---            ------      ------- ---------- ------

    1          Bovine            0.90216     (  0.50346,     1.30086) **
    1          Mouse             0.79240     (  0.42191,     1.16297) **
    1             2              0.48553     (  0.16602,     0.80496) **
    2             3              0.12113     (     zero,     0.24676) *
    3             4              0.04895     (     zero,     0.12668)
    4             5              0.07459     (  0.00735,     0.14180) **
    5          Human             0.10563     (  0.04234,     0.16889) **
    5          Chimp             0.17158     (  0.09765,     0.24553) **
    4          Gorilla           0.15266     (  0.07468,     0.23069) **
    3          Orang             0.30368     (  0.18735,     0.41999) **
    2          Gibbon            0.33636     (  0.19264,     0.48009) **

      *  = significantly positive, P < 0.05
      ** = significantly positive, P < 0.01
</PRE>
</TD></TR></TABLE>
<P>
Ignoring the asterisks and the approximate confidence limits, which will be
described in the documentation file for DNAML, we can see that the table
gives a more precise idea of what the lengths of all the branches are.
Similar tables exist in distance matrix and likelihood programs, as well
as in the parsimony programs DNAPARS and PARS.
<P>
Some of the parsimony programs in the package can print out a table
of the number of steps that different characters (or sites) require on
the tree.  This table may not be obvious at first.  A typical example looks like
this:
<P>
<TABLE><TR><TD BGCOLOR=white>
<PRE>
 steps in each site:
         0   1   2   3   4   5   6   7   8   9
     *-----------------------------------------
    0!       2   2   2   2   1   1   2   2   1
   10!   1   2   3   1   1   1   1   1   1   2
   20!   1   2   2   1   2   2   1   1   1   2
   30!   1   2   1   1   1   2   1   3   1   1
   40!   1
</PRE>
</TD></TR></TABLE>
<P>
The numbers across the top and down the side indicate which site
is being referred to.  Thus site 23 is column "3" of row "20"
and has 1 step in this case.
<P>
There are many other kinds of information that can appear in the
output file,  They vary from program to program, and we leave their
description to the documentation files for the specific programs.
<P>
<A NAME="treefile"><HR><P></A>
<H2>The Tree File</H2>
<P>
In output from most programs,
a representation of the tree is also written into the tree file
<TT>outtree</TT>.  The tree is specified by nested pairs
of parentheses, enclosing
names and separated by commas.  We will describe how this works
below.  If there are any blanks in the names,
these must be replaced by the underscore character "<TT>_</TT>".  Trailing blanks
in the name may be omitted.  The pattern of the parentheses indicates
the pattern of the tree by having each pair of parentheses enclose all
the members of a monophyletic group.  The tree file could look like this:
<P>
<TT>((Mouse,Bovine),(Gibbon,(Orang,(Gorilla,(Chimp,Human)))));
</TT>
<P>
In this tree the first fork separates the lineage leading to
<TT>Mouse</TT> and <TT>Bovine</TT> from the lineage leading to the rest.  Within the 
latter group there is a fork separating <TT>Gibbon</TT> from the rest, and so on.
The entire tree is enclosed in an outermost pair of parentheses.  The tree ends
with a semicolon.  In some programs such as DNAML, FITCH, and CONTML,
the tree will be unrooted.  An unrooted tree should have its 
bottommost fork have a
three-way split, with three groups separated by two commas:
<P>
<TT>(A,(B,(C,D)),(E,F));
</TT>
<P>
Here the three groups at the bottom node are <TT>A</TT>, <TT>(B,C,D)</TT>, and
<TT>(E,F)</TT>.  The single three-way split corresponds to one of the interior
nodes of the unrooted tree (it can be any interior node of the tree).  The
remaining forks are encountered as you move out from that first node.
In newer programs, some are able to tolerate these other forks being
multifurcations (multi-way splits).
You should check the documentation files
for the particular programs you are using to see in which of these forms
you can expect the user tree to be in.  Note that many of the programs
that actually estimate an unrooted tree (such as DNAPARS) produce trees in the
treefile in rooted form!  This is done for reasons of arbitrary internal bookkeeping.  The placement of the root is arbitrary.  We are working toward
having all programs be able to read all trees, whether rooted or unrooted,
multifurcating or bifurcating, and having them do the right thing with
them.  But this is a long-term goal and it is not yet achieved.
<P>
For programs that infer branch lengths, these are given in the trees in the
tree file as real numbers following a colon, and placed immediately
after the group descended from that branch.  Here is a typical tree
with branch lengths:
<P>
<TT>((cat:47.14069,(weasel:18.87953,((dog:25.46154,(raccoon:19.19959,<BR>
bear:6.80041):0.84600):3.87382,(sea_lion:11.99700,<BR>
seal:12.00300):7.52973):2.09461):20.59201):25.0,monkey:75.85931);
</TT>
<P>
Note that the tree may continue to a new line at any time except in the
middle of a name or the middle of a branch length, although in trees
written to the tree file this will only be done after a comma.
<P>
These representations of trees are a subset of the standard adopted
on 24 June 1986 at the annual meetings of the Society for the Study of
Evolution by an informal committee (its final session in Newick's
lobster restaurant - hence its name, the Newick standard)
consisting of Wayne Maddison (author of MacClade), David Swofford (PAUP),
F. James Rohlf (NTSYS-PC), Chris Meacham (COMPROB and the original
PHYLIP tree drawing programs), James Archie,
William H.E. Day, and me.  This standard is a generalization of
PHYLIP's format, itself based on a well-known representation of trees in 
terms of parenthesis patterns which is due to the famous mathematician 
Arthur Cayley, and which has been around for over a century.  The
standard is now employed by most phylogeny computer programs but unfortunately
has yet to be decribed in a formal published description.  Other
descriptions by me and by Gary Olsen can be accessed using the Web at:
<P>
<DIV ALIGN="CENTER">
<FONT SIZE=+2><A HREF="http://evolution.gs.washington.edu/phylip/newicktree.html">
<TT>http://evolution.gs.washington.edu/phylip/newicktree.html</TT></A></FONT>
</DIV>
<P>
<A NAME="options"><HR><P></A>
<H2>The Options and How To Invoke Them</H2>
<P>
Most of the programs allow various options that alter the amount of
information the program is provided or what is done with the
information.  Options are selected in the menu.
<P>
<H3>Common options in the menu</H3>
<P>
A number of the options from the menu, the <TT>U</TT> (User tree), <TT>G</TT> (Global),
<TT>J</TT> (Jumble), <TT>O</TT> (Outgroup), <TT>W</TT> (Weights),
<TT>T</TT> (Threshold), <TT>M</TT> (multiple data sets), and the tree output options, are used
so widely that it is best to discuss them in this document.
<P>
<B>The <TT>U</TT> (User tree) option.</B>  This option toggles between the default
setting, which allows the program to search for the best tree, and the
User tree setting, which reads a tree or trees ("user trees") from the input
tree file and evaluates them.  The input tree file's
default name is <TT>intree</TT>.  In a few cases the trees should
be preceded by a line giving the number of trees:
<P>
<TABLE><TR><TD BGCOLOR=white>
<PRE>
   3
((Alligator,Bear),((Cow,(Dog,Elephant)),Ferret));
((Alligator,Bear),(((Cow,Dog),Elephant),Ferret));
((Alligator,Bear),((Cow,Dog),(Elephant,Ferret)));
</PRE>
</TD></TR></TABLE>
<P>
while in most cases the initial line with the number of trees is not
required.  This is an inconsistency in the programs that we are intending
to eliminate soon.  Some programs require rooted trees, some unrooted
trees, and some can handle multifurcating trees.  You should read
the documentation for the particular program to find out which it
requires.  Program RETREE can be used to convert trees among
these forms (on saving a tree from RETREE, you are asked whether
you want it to be rooted or unrooted).
<P>
In using the user tree option, check the pattern of parentheses
carefully.  The programs do not always detect
whether the tree makes sense, and if it does not there will probably be
a crash (hopefully, but not inevitably, with an error message indicating
the nature of the problem).  Trees written out by programs are
typically in the proper form.
<P>
Some of the programs require that the user trees be preceded by line with the
number of user trees.  Some require that they <EM>not</EM> be preceded by
this line, and many can tolerate either.  I have tried to note for
each of these programs which of these forms of the user tree file
is appropriate.  We hope to bring all programs to the same user tree file
format as soon as possible.
<P>
<B>The <TT>G</TT> (Global) option.</B>  In  the programs which construct trees (except for
NEIGHBOR, the "...PENNY" programs and CLIQUE, and of course 
the "...MOVE" programs where you construct the trees yourself),
after all species have been added to the tree a rearrangements phase
ensues.  In most of these programs the rearrangements are automatically
global, which in this case means that subtrees will be removed from the tree
and put back on in all possible ways so as to have a better chance of
finding a better tree.  Since this can be time consuming (it roughly
triples the time taken for a run) it is left as an option in some of the
programs, specifically CONTML, FITCH, and DNAML.  In these programs
the G menu option toggles between the default of local rearrangement and
global rearrangement.  The rearrangements are explained more below.
<P>
<B>The <TT>J</TT> (Jumble) option.</B>  In most of the tree construction programs
(except for the "...PENNY" programs and CLIQUE), the exact 
details of the search of different trees depend on the order of input of
species.  In these programs <TT>J</TT> option enables you to tell the program to use
a random number 
generator to choose the input order of species.  This option is toggled on
and off by
selecting option <TT>J</TT> in the menu.  The program will then prompt you for
a "seed" for the random number generator.  The seed should be an integer
between 1 and 32767, and should of form 4n+1, 
which means that it must give a remainder of 1 when divided by 4.  This can be
judged by looking at the last two digits of the number.  Each different seed 
leads to a different sequence of addition of species.  By simply changing the 
random number seed and re-running the programs one can look for other, and 
better trees.  If the seed entered is not odd, the program will not proceed,
but will prompt for another seed.
<P>
The Jumble option also causes the program to ask you how many times you
want to restart the process.  If you answer 10, the program will
try ten different orders of species in constructing the trees, and the
results printed out will reflect this entire search process (that is,
the best trees found among all 10 runs will be printed out, not the
best trees from each individual run).
<P>
Some people have asked what are good values of the random number seed.
The random number seed is used to start a process of choosing "random"
(actually pseudorandom) numbers, which behave as if they were
unpredictably randomly chosen between 0 and 2<SUP>32</SUP>-1 (which is
4,294,967,296).  You could put in the number 133 and find that the
next random number was 1,876,973,009.  As they are effectively
unpredictable, there is no such thing as a choice that is better than
any other, provided that the numbers are of the form 4<I>n</I>+1.  However
if you re-use a random number seed, the sequence of random numbers
that result will be the same as before, resulting in exactly the same
series of choices, which may not be what you want.
<P>
<B>The <TT>O</TT> (Outgroup) option.</B>  This specifies which species is to be used
to root the tree by having it become the outgroup.  This option is
toggled on and off by choosing <TT>O</TT> in the menu (the alphabetic
character <TT>O</TT>, not the digit <TT>0</TT>).  When it is on, the program will
then prompt for the
number of the outgroup (the species being taken in the numerical order that
they occur in the input file).  Responding by typing <TT>6</TT> and then an
<TT>Enter</TT> character indicates that the sixth species in the data
is the outgroup.  Outgroup-rooting will not be attempted if the
data have already established a root for the tree from some other 
consideration, and may not be if it is a user-defined tree,
despite your invoking the option.  Thus programs such as DOLLOP that
produce only rooted trees do not allow the Outgroup option.  It is also
not available in KITSCH, DNAMLK, or CLIQUE.  When it is used, the tree as
printed out is still listed as being an
unrooted tree, though the outgroup is connected to the bottommost node
so that it is easy to visually convert the tree into rooted form.
<P>
<B>The <TT>T</TT> (Threshold) option.</B>  This sets a threshold forn the
parsimony programs such that if the
number of steps counted in a character is higher than the threshold, it
will be taken to be the threshold value rather than the actual number of
steps.  The default is a threshold so high that it will never be
surpassed (in which case the steps whill simply be counted).  The <TT>T</TT>
menu option toggles on and off asking the user to
supply a threshold.  The use of thresholds to obtain methods intermediate
between parsimony and compatibility methods is described in my 1981b paper. 
When the T option is in force, the program
will prompt for the numerical threshold value.  This will be a positive
real number greater than 1.  In programs MIX, MOVE, PENNY, PROTPARS,
DNAPARS, DNAMOVE, and DNAPENNY, do not use threshold values less
than or equal to 1.0, as they have no meaning and lead to a tree which
depends only on considerations such as the input order of species and not at 
all on the character state data!  In programs DOLLOP, DOLMOVE, and DOLPENNY
the threshold should never be 0.0 or less, for the same
reason.  The <TT>T</TT> option is an 
important and underutilized one: it is, for example, the only way in this 
package (except for program DNACOMP) to do a compatibility analysis when there 
are missing data.   It is a method of de-weighting characters that evolve
rapidly.  I wish more people were aware of its properties.  
<P>
<B>The <TT>M</TT> (Multiple data sets) option.</B>  In menu programs there is an
<TT>M</TT> menu
option which allows one to toggle on the multiple data sets option.  The
program will ask you how many data sets it should expect.  The data sets
have the same format as the first data set.  Here is a (very small) input file
with two five-species data sets:
<P>
<TABLE><TR><TD bgcolor=white>
<PRE>
      5    6
Alpha     CCACCA
Beta      CCAAAA
Gamma     CAACCA
Delta     AACAAC
Epsilon   AACCCA
5    6
Alpha     CACACA
Beta      CCAACC
Gamma     CAACAC
Delta     GCCTGG
Epsilon   TGCAAT
</PRE>
</TD></TR></TABLE>
<P>
The main use of this option will be to allow all of the methods in these
programs to be bootstrapped.  Using the program SEQBOOT one can take any
DNA, protein, restriction sites, gene frequency or binary character data set and
make multiple data sets by bootstrapping.  Trees can be produced for all of
these using the <TT>M</TT> option.  They will be written on the tree output file if
that option is left in force.  Then the program CONSENSE can be used with
that tree file as its input file.  The result is a majority rule consensus
tree which can be used to make confidence intervals.  The present version
of the package allows, with the use of SEQBOOT and CONSENSE and the M option,
bootstrapping of many of the methods in the package.
<P>
Programs DNAML, DNAPARS and PARS can also take multiple weights
instead of multiple data sets.  They can then do bootstrapping by
reading in one data set, together with a file of weights that show how
the characters (or sites) are reweighted in each bootstrap sample.  Thus a
site that is omitted in a bootstrap sample has effectively been given
weight 0, while a site that has been duplicated has effectively been
given weight 2.  SEQBOOT has a menu selection to produce the file of
weights information automatically, instead of producing a file of
multiple data sets.
<P>
<B>The <TT>W</TT> (Weights) option</B>.  This signals the program that, in
addition to the data set, you want to read in a series of weights that
tell how many times each character is to be counted.  If the weight
for a character is zero (<TT>0</TT>) then that character is in effect to
be omitted when the tree is evaluated.  If it is (<TT>1</TT>) the
character is to be counted once.  Some programs allow weights greater than
1 as well.  These have the effect that the character is counted as
if it were present that many times, so that a weight of 4 means that the
character is counted 4 times.
The values 0-9 give weights 0 through 9, and the
values A-Z give weights 10 through 35.  By use of the weights we can
give overwhelming weight to some characters, and drop others from the
analysis.  In the molecular sequence programs only two values of the
weights, 0 or 1 are allowed.
<P>
The weights are used to analyze subsets of the characters, and also can be
used for resampling of the data as in bootstrap and jackknife resampling.
For those programs that allow weights to be greater than 1, they can also
be used to emphasize information from some characters more strongly than
others.  Of course, you must have some rationale for doing this.
<P>
The weights are provided as a sequence of digits.  Thus they might be
<P>
<TT>10011111100010100011110001100</TT>
<P>
The weights are to be provided in an input file
whose default name is <TT>weights</TT>.  In programs such as SEQBOOT
that can also output a file of weights, the input weights have a default
file name of <TT>inweights</TT>, and the output file name has a default
file name of <TT>outweights</TT>. 
<P>
Weights can be used to analyze different subsets of characters (by weighting
the rest as zero).  Alternatively, in the discrete characters programs
they can be used to force a certain
group to appear on the phylogeny (in effect confining consideration to only
phylogenies containing that group).  This is done by adding an imaginary
character that has <TT>1</TT>'s for the members of the group, and <TT>0</TT>'s
for all the
other species.  That imaginary character is then given the highest weight
possible: the result will be that any phylogeny that does not contain that
group will be penalized by such a heavy amount that it will not (except in
the most unusual circumstances) be considered.  Of course, the new character
brings extra steps to the tree, but the number of these can be calculated
in advance and subtracted out of the total when reporting the results.  This 
use of weights is an important one, and one sadly ignored
by many users who could profit from it.  In the case of molecular sequences
we cannot use weights this way, so that to force a given group to appear we
have to add a large extra segment of sites to the molecule, with (say) A's
for that group and C's for every other species.
<P>
<B>The option to write out the trees into a tree file</B>.  This specifies that you
want the program to write
out the tree not only on its usual output, but also onto a file in
nested-parenthesis notation (as described above).  This option is sufficiently
useful that it is turned on by default in all programs that allow it.  You
can optionally turn it off if you wish, by typing the appropriate number
from the menu (it varies from program to program).  This option is useful for
creating tree files that can be directly read into the programs, including
the consensus tree and tree distance programs, and the tree plotting programs.
<P>
The output tree file has a default name of <TT>outtree</TT>.
<P>
<B>The (<TT>0</TT>) terminal type option</B> .  (This is the digit <TT>0</TT>, not
the alphabetic character <TT>O</TT>). The program will default to
one particular assumption about your terminal (except in the case of
Macintoshes, the default will be an ANSI compatible terminal). You can
alternatively select it to be either an IBM PC, or nothing.
This affects the ability of the programs to clear the screen when they
display their menus, and the graphics characters used to display trees
in the programs DNAMOVE, MOVE, DOLMOVE, and RETREE.  If you are running an
MSDOS system and have the ANSI.SYS driver installed in your CONFIG.SYS
file, you may find that the screen clears correctly even with the default
setting of ANSI.
<P>
<A NAME="algorithm"><HR><P></A>
<DIV ALIGN="CENTER">
<H2>The Algorithm for Constructing Trees</H2></DIV>
<P>
All of the programs except FACTOR, DNADIST, GENDIST, DNAINVAR, SEQBOOT,
CONTRAST, RETREE, and the plotting and
consensus tree programs act to construct an estimate of a phylogeny.  MOVE, 
DOLMOVE, and DNAMOVE let you construct it yourself by hand.  All of 
the rest but NEIGHBOR, the "...PENNY" programs and CLIQUE make use of
a common approach involving additions and rearrangements.  They are
trying to minimize or maximize some quantity over the space of all
possible evolutionary trees.  Each program contains a part that, given
the topology of the tree, evaluates the quantity that is being minimized
or maximized.  The straightforward approach would be to evaluate all
possible tree topologies one after another and pick the one which,
according to the criterion being used, is best.  This would not be
possible for more than a small number of species, since the number of
possible tree topologies is enormous.  A review of the literature on the
counting of evolutionary trees will be found one of my papers
(Felsenstein, 1978a).
<P>
Since we cannot search all topologies, these programs are not
guaranteed to always find the best tree, although they seem to do quite
well in practice.  The strategy they employ is as follows: the species
are taken in the order in which they appear in the input file.  The
first two (in some programs the first three) are taken and a tree
constructed containing only those.  There is only one possible topology for
this tree.  Then the next species is taken, and we consider where it
might be added to the tree.  If the initial tree is (say) a rooted tree
with two species and we want the resulting three-species tree to be a
bifurcating tree, there are only three places where we could add the
third species.  Each of these is tried, and each time the resulting tree is
evaluated according to the criterion.  The best one is chosen to be the
basis for further operations.  Now we consider adding the fourth
species, again at each of the five possible places that would result in
a bifurcating tree.  Again, the best of these is accepted.
<P>
<H3>Local Rearrangements</H3>
<P>
The process continues in this manner, with one important exception.  After 
each species is added, and before the next
is added, a number of rearrangements of the tree are tried, in an effort
to improve it.  The algorithms move through the tree, making all
possible local rearrangements of the tree.  A local rearrangement involves an
internal segment of the tree in the following manner.  Each internal
segment of the tree is of this form (where T1, T2, and T3 are subtrees
- parts of the tree that can contain further forks and tips):
<P>
<PRE>
            T1      T2       T3
             \      /        /
              \    /        /
               \  /        /
                \/        /
                 *       /
                  *     /
                   *   /
                    * /
                     *
                     !
                     !
</PRE>
<P>
the segment we are discussing being indicated by the asterisks.  A local
rearrangement consists of switching the subtrees T1 and T3 or T2 and T3,
so as to obtain one of the following:
<P>
<PRE>
          T3       T2      T1            T1       T3      T2
           \       /       /              \       /       /
            \     /       /                \     /       /
             \   /       /                  \   /       /
              \ /       /                    \ /       /
               \       /                      \       /
                \     /                        \     /
                 \   /                          \   /
                  \ /                            \ /
                   !                              !
                   !                              !
                   !                              !
</PRE>
<P>
Each time a local rearrangement is successful in finding a better tree,
the new arrangement is accepted.  The phase of local rearrangements does
not end until the program can traverse the entire tree, attempting local
rearrangements, without finding any that improve the tree.
<P>
This strategy of adding species and making local rearrangements will look
at about &nbsp;(n-1)x(2n-3)&nbsp; different topologies, though if
rearrangements are frequently successful the number may be larger.  I
have been describing the strategy when rooted trees are being
considered.  For unrooted trees there is a precisely similar strategy,
though the first tree constructed may be a three-species tree and the
rearrangements may not start until after the addition of the fifth
species.
<P>
Though we are not guaranteed to have found the best tree topology,
we are guaranteed that no nearby topology (i. e.  none accessible by a
single local rearrangement) is better.  In this sense we have reached a
local optimum of our criterion.  Note that the whole process is
dependent on the order in which the species are present in the input
file.  We can try to find a different and better solution by reordering
the species in the input file and running the program again (or, more
easily, by using the <TT>J</TT> option).  If none of
these attempts finds a better solution, then we have some indication
that we may have found the best topology, though we can never be certain
of this.
<P>
Note also that a new topology is never accepted unless it is better
than the previous one, so that the rearrangement process can never fall
into an endless loop.  This is also the way ties in our criterion are
resolved, namely by sticking with the tree found first.  However, the tree 
construction programs other than CLIQUE, CONTML, FITCH, 
and DNAML do keep a record of all trees found that are tied with the best one 
found.  This gives you some immediate idea of which parts of the tree can be 
altered without affecting the quality of the result.
<P>

<H3>Global Rearrangements</H3>
<P>
A feature of most of the programs, such as PROTPARS, DNAPARS,
DNACOMP, DNAML, DNAMLK, RESTML, KITSCH, FITCH, CONTML, MIX, and DOLLOP,
is "global" optimization of the tree.  In four of these (CONTML,
FITCH, DNAML and DNAMLK) this is an option, <TT>G</TT>.  In the others it
automatically applies.  When 
it is present there is an additional stage to the search for the best tree.  
Each possible subtree is removed from the tree from the tree and added back in 
all possible places.  This process continues until all subtrees can be removed 
and added again without any improvement in the tree.  The purpose of this 
extra rearrangement is to make it less likely that one or more a species gets 
"stuck" in a suboptimal region of the space of all possible trees.  The use of 
global optimization results in approximately a tripling (3 x ) of the run-time, 
which is why I have left it as an option in some of the slower programs.
<P>
What PHYLIP calls "global" rearrangements are more properly called
SPR (subtree pruning and regrafting) by Swofford et. al. (1996) as distinct
from the NNI (nearest neighbor interchange) rearrangements that PHYLIP
also uses, and the TBR (tree bisection and reconnection) rearrangements
that it does not use.
<P>
The programs doing global optimization print out a dot "<TT>.</TT>" after each group is 
removed and re-added to the tree, to give the user some sign that the 
rearrangements are proceeding.  A new line of dots is started whenever a new 
round of global rearrangements is started following an improvement in the 
tree.  On the line before the dots are printed there is printed a bar of
the form "!---------------!" to show how many dots
to expect.  The dots will
not be printed out at a uniform rate, but the later dots, which represent
removal of larger groups from the tree and trying them consequently in fewer
places, will print out more quickly.  With some compilers each row of dots may
not be printed out until it is complete.
<P>
It should be noted that PENNY, DOLPENNY, DNAPENNY and CLIQUE use a more 
sophisticated strategy of "depth-first search" with a "branch and bound"
search method that guarantees that all
of the best trees will be found.  In the case 
of PENNY, DOLPENNY and DNAPENNY there can be a considerable sacrifice of 
computer time if the number of species is greater than about ten: it is a 
matter for you to consider whether it is worth it for you to guarantee finding 
all the most parsimonious trees, and that depends on how much free computer 
time you have!  CLIQUE finds all largest cliques, and does so without undue 
burning of computer time.   Although all of these problems that have been
investigated fall into the
category of "NP-hard" problems that in effect do not have a rapid solution,
the cases that cause this trouble for the largest-cliques algorithm in
CLIQUE apparently are not biologically realistic and do not occur in actual
data.
<P>

<H3>Multiple Jumbles</H3>
<P>
As just mentioned, for most of these programs the search depends on the order
in which the species are entered into the tree.  Using the <TT>J</TT> (Jumble)
option you can supply a random number seed which will allow the program to put
the species in in a random order.  Jumbling can be
done multiple times.  For example, if you tell the program to do it
10 times, it will go through the tree-building process 10 times, each with a
different random order of adding species.  It will keep a record of the trees
tied for best over the whole process.  In other words, it does not just
record the best trees from each of the 10 runs, but records the best ones
overall.  Of course this is slow, taking 10 times longer than a single run.
But it does give us a much greater chance of finding all of the most
parsimonious trees.  In the terminology of Maddison (1991) it
can find different "islands" of trees.  The present algorithms do not
guarantee us to find all trees in a given "island" from a single run, so
multiple runs also help explore those "islands" that are found.
<P>
<H3>Saving multiple tied trees</H3>
<P>
For the parsimony and compatibility programs, one can have a perfect tie
between two or more trees.  In these programs these trees are all
saved.  For the newer parsimony programs such as DNAPARS and PARS,
global rearrangement is carried out on all of these tied trees.  This can
be turned off in the menu.
<P>
For trees with criteria which are real numbers, such as the distance
matrix programs FITCH and KITSCH, and the likelihood programs DNAML,
DNAMLK, CONTML, and RESTML, it is difficult to get an exact tie between
trees.  Consequently these programs save only the single best tree
(even though the others may be only a tiny bit worse).
<P>
<H3>Strategy for Finding the Best Tree</H3>
<P>
In practice, it is advisable to use the Jumble option to evaluate many
different orderings of the input species.  <I>It is advisable to use the
Jumble option and specify that it be done many times (as many as ten)</I>
to use different orderings
of the input species).
<P>
People who want a magic "black box" program whose results they do
not have to question (or think about) often are upset that these
programs give results that are dependent on the order in which the species
are entered in the data.  To me this property is an advantage, for it
permits you to try different searches for better trees, simply by
varying the input order of species.  If you do not use the multiple Jumble
option, but do multiple individual runs instead, you
can easily decide which to pay most attention to - the one or ones that 
are best according to the criterion employed (for example, with parsimony, 
the one out of the runs that results in the tree with the fewest changes).
<P>
In practice, in a single run, it usually seems best to put species that are
likely to be sources of confusion in the topology last, as by the time they are
added the arrangement of the earlier species will have stabilized into a
good configuration, and then the last few species will by fitted into
that topology.  There will be less chance this way of a poor initial
topology that would affect all subsequent parts of the search.  However,
a variety of arrangements of the input order of species should be tried,
as can be done if the <TT>J</TT> option is used,
and no species should be kept in a fixed place in the order of input.
Note that the results of the "...PENNY" programs and CLIQUE
are not sensitive to the input order of species, and NEIGHBOR is only
slightly sensistive to it, so that multiple Jumbling is not possible
with those programs.  Note also that with global search, which
is standard in many programs and in others is an 
option, each group (including
each individual species) will be removed and re-added in all possible
positions, so that a species causing confusion will have more chance of moving
to a new location than it would without global rearrangement.
<P>
<A NAME="warning"><HR><P></A>
<DIV ALIGN="CENTER">
<H2>A Warning on Interpreting Results</H2></DIV>
<P>
Probably the most important thing to keep in mind while running any of the
parsimony or compatibility programs is not
to overinterpret the result.  Many users treat the set of most parsimonious
trees as if it were a confidence interval.  If a group appears in all of the
most parsimonious trees then they treat it as well established.  Unfortunately
<I>the confidence interval on phylogenies appears to be much
larger than the set of all most parsimonious trees</I> (Felsenstein, 1985b).
Likewise, variation of result among different methods will not be a good
indicator of the size of the confidence interval.  Consider a simple data set
in which, out of 100 binary characters, 51 recommend the unrooted tree
<TT>((A,B),(C,D))</TT> and 49 the tree <TT>((A,D),(B,C))</TT>.  Many different
methods will all give the same result on
such a data set: they will estimate the tree as <TT>((A,B),(C,D))</TT>.
Nevertheless it is
clear that the 51:49 margin by which this tree is favored is not statistically
significantly different from 50:50.  So <I>consistency among different methods
is a poor guide to statistical significance</I>.
<P>
<A NAME="speed"><HR><P></A>
<DIV ALIGN="CENTER">
<H2>Relative Speed of Different<BR>
Programs and Machines</H2></DIV>
<P>
<H3>Relative speed of the different programs</H3>
<P>
C compilers differ in efficiency of the code they generate,
and some deal with some features of the language better than with
others.  Thus a program which is unusually fast on one computer may be
unusually slow on another.  Nevertheless, as a rough guide to relative
execution speeds, I have tested the programs on three data sets, each of
which has 10 species and 40 characters.  The first is an imaginary one
in which all characters are compatible - ("The Willi Hennig Memorial
Data Set" as J. S. Farris once called ones like it).  The second is the binary
recoded form of the fossil horses data set of Camin and Sokal (1965).
The third data set has data that is completely random: 10 species and 20
characters that have a 50% chance that each character state is <TT>0</TT> or
<TT>1</TT> (or <TT>A</TT> or <TT>G</TT>).  The data sets thus range from a completely
compatible one in which there is no homoplasy (paralellism or convergence), 
through the horses data set, which requires 29 steps where the possible 
minimum number would be 20, to the random data set, which requires 49 steps.  
We can thus see how this increasing messiness of the data affects running 
times.  The three data sets have all had 20 sites of <TT>A</TT>'s added to the 
end of each sequence, so as to prevent likelihood or distance matrix programs 
from having infinite branch lengths (the test data sets used for timing
previous versions of PHYLIP wsere the same except that they lacked these
20 extra sites).
<P>
Here are the nucleotide sequence versions of the three data sets:
<P>
<TABLE><TR><TD BGCOLOR=white>
<PRE>
    10   40
A         CACACACAAAAAAAAAAACAAAAAAAAAAAAAAAAAAAAA
B         CACACAACAAAAAAAAAACAAAAAAAAAAAAAAAAAAAAA
C         CACAACAAAAAAAAAAAACAAAAAAAAAAAAAAAAAAAAA
D         CAACAAAACAAAAAAAAACAAAAAAAAAAAAAAAAAAAAA
E         CAACAAAAACAAAAAAAACAAAAAAAAAAAAAAAAAAAAA
F         ACAAAAAAAACACACAAAACAAAAAAAAAAAAAAAAAAAA
G         ACAAAAAAAACACAACAAACAAAAAAAAAAAAAAAAAAAA
H         ACAAAAAAAACAACAAAAACAAAAAAAAAAAAAAAAAAAA
I         ACAAAAAAAAACAAAACAACAAAAAAAAAAAAAAAAAAAA
J         ACAAAAAAAAACAAAAACACAAAAAAAAAAAAAAAAAAAA
</PRE>
</TD></TR></TABLE>
<P>
<TABLE><TR><TD BGCOLOR=white>
<PRE>
    10   40
MesohippusAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
HypohippusAAACCCCCCCAAAAAAAAACAAAAAAAAAAAAAAAAAAAA
ArchaeohipCAAAAAAAAAAAAAAAACACAAAAAAAAAAAAAAAAAAAA
ParahippusCAAACAACAACAAAAAAAACAAAAAAAAAAAAAAAAAAAA
MerychippuCCAACCACCACCCCACACCCAAAAAAAAAAAAAAAAAAAA
M. secunduCCAACCACCACCCACACCCCAAAAAAAAAAAAAAAAAAAA
Nannipus  CCAACCACAACCCCACACCCAAAAAAAAAAAAAAAAAAAA
NeohippariCCAACCCCCCCCCCACACCCAAAAAAAAAAAAAAAAAAAA
Calippus  CCAACCACAACCCACACCCCAAAAAAAAAAAAAAAAAAAA
PliohippusCCCACCCCCCCCCACACCCCAAAAAAAAAAAAAAAAAAAA
</PRE>
</TD></TR></TABLE>
<P>
<TABLE><TR><TD BGCOLOR=white>
<PRE>
    10   40
A         CACACAACCAAACAAACCACAAAAAAAAAAAAAAAAAAAA
B         AAACCACACACACAAACCCAAAAAAAAAAAAAAAAAAAAA
C         ACAAAACCAAACCACCCACAAAAAAAAAAAAAAAAAAAAA
D         AAAAACACAACACACCAAACAAAAAAAAAAAAAAAAAAAA
E         AAACAACCACACACAACCAAAAAAAAAAAAAAAAAAAAAA
F         CCCAAACACCCCCAAAAAACAAAAAAAAAAAAAAAAAAAA
G         ACACCCCCACACCCACCAACAAAAAAAAAAAAAAAAAAAA
H         AAAACAACAACCACCCCACCAAAAAAAAAAAAAAAAAAAA
I         ACACAACAACACAAACAACCAAAAAAAAAAAAAAAAAAAA
J         CCAAAAACACCCAACCCAACAAAAAAAAAAAAAAAAAAAA
</PRE>
</TD></TR></TABLE>
<P>
Here are the timings of many of the version 3.6 programs on these three data
sets as run after being compiled by Gnu C and run on a
266 MHz Pentium MMX computer under Linux.
<P>
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="RIGHT">Hennigian Data</TD>
<TD ALIGN="RIGHT">Horses Data</TD>
<TD ALIGN="RIGHT">Random Data</TD>
</TR>
<TR><TD ALIGN="LEFT">PROTPARS</TD>
<TD ALIGN="RIGHT">0.133</TD>
<TD ALIGN="RIGHT">0.167</TD>
<TD ALIGN="RIGHT">0.308</TD>
</TR>
<TR><TD ALIGN="LEFT">DNAPARS</TD>
<TD ALIGN="RIGHT">0.163</TD>
<TD ALIGN="RIGHT">0.191</TD>
<TD ALIGN="RIGHT">0.573</TD>
</TR>
<TR><TD ALIGN="LEFT">DNAPENNY</TD>
<TD ALIGN="RIGHT">0.300</TD>
<TD ALIGN="RIGHT">0.196</TD>
<TD ALIGN="RIGHT">36.68</TD>
</TR>
<TR><TD ALIGN="LEFT">DNACOMP</TD>
<TD ALIGN="RIGHT">0.081</TD>
<TD ALIGN="RIGHT">0.073</TD>
<TD ALIGN="RIGHT">0.127</TD>
</TR>
<TR><TD ALIGN="LEFT">DNAML</TD>
<TD ALIGN="RIGHT">2.19</TD>
<TD ALIGN="RIGHT">2.53</TD>
<TD ALIGN="RIGHT">2.73</TD>
</TR>
<TR><TD ALIGN="LEFT">DNAMLK</TD>
<TD ALIGN="RIGHT">5.40</TD>
<TD ALIGN="RIGHT">6.13</TD>
<TD ALIGN="RIGHT">7.21</TD>
</TR>
<TR><TD ALIGN="LEFT">PROML</TD>
<TD ALIGN="RIGHT">44.79</TD>
<TD ALIGN="RIGHT">90.46</TD>
<TD ALIGN="RIGHT">68.49</TD>
</TR>
<TR><TD ALIGN="LEFT">PROMLK</TD>
<TD ALIGN="RIGHT">171.01</TD>
<TD ALIGN="RIGHT">183.61</TD>
<TD ALIGN="RIGHT">239.34</TD>
</TR>
<TR><TD ALIGN="LEFT">DNAML</TD>
<TD ALIGN="RIGHT">2.19</TD>
<TD ALIGN="RIGHT">2.53</TD>
<TD ALIGN="RIGHT">2.73</TD>
</TR>
<TR><TD ALIGN="LEFT">DNAINVAR</TD>
<TD ALIGN="RIGHT">0.002</TD>
<TD ALIGN="RIGHT">0.002</TD>
<TD ALIGN="RIGHT">0.002</TD>
</TR>
<TR><TD ALIGN="LEFT">DNADIST</TD>
<TD ALIGN="RIGHT">0.029</TD>
<TD ALIGN="RIGHT">0.024</TD>
<TD ALIGN="RIGHT">0.033</TD>
</TR>
<TR><TD ALIGN="LEFT">PROTDIST</TD>
<TD ALIGN="RIGHT">1.095</TD>
<TD ALIGN="RIGHT">1.089</TD>
<TD ALIGN="RIGHT">1.107</TD>
</TR>
<TR><TD ALIGN="LEFT">RESTML</TD>
<TD ALIGN="RIGHT">3.55</TD>
<TD ALIGN="RIGHT">3.18</TD>
<TD ALIGN="RIGHT">5.15</TD>
</TR>
<TR><TD ALIGN="LEFT">RESTDIST</TD>
<TD ALIGN="RIGHT">0.012</TD>
<TD ALIGN="RIGHT">0.010</TD>
<TD ALIGN="RIGHT">0.010</TD>
</TR>
<TR><TD ALIGN="LEFT">FITCH</TD>
<TD ALIGN="RIGHT">0.20</TD>
<TD ALIGN="RIGHT">0.31</TD>
<TD ALIGN="RIGHT">0.24</TD>
</TR>
<TR><TD ALIGN="LEFT">KITSCH</TD>
<TD ALIGN="RIGHT">0.055</TD>
<TD ALIGN="RIGHT">0.061</TD>
<TD ALIGN="RIGHT">0.058</TD>
</TR>
<TR><TD ALIGN="LEFT">NEIGHBOR</TD>
<TD ALIGN="RIGHT">0.003</TD>
<TD ALIGN="RIGHT">0.004</TD>
<TD ALIGN="RIGHT">0.005</TD>
</TR>
<TR><TD ALIGN="LEFT">CONTML</TD>
<TD ALIGN="RIGHT">0.380</TD>
<TD ALIGN="RIGHT">0.368</TD>
<TD ALIGN="RIGHT">0.396</TD>
</TR>
<TR><TD ALIGN="LEFT">GENDIST</TD>
<TD ALIGN="RIGHT">0.008</TD>
<TD ALIGN="RIGHT">0.009</TD>
<TD ALIGN="RIGHT">0.008</TD>
</TR>
<TR><TD ALIGN="LEFT">PARS</TD>
<TD ALIGN="RIGHT">0.201</TD>
<TD ALIGN="RIGHT">0.263</TD>
<TD ALIGN="RIGHT">0.729</TD>
</TR>
<TR><TD ALIGN="LEFT">MIX</TD>
<TD ALIGN="RIGHT">0.064</TD>
<TD ALIGN="RIGHT">0.078</TD>
<TD ALIGN="RIGHT">0.123</TD>
</TR>
<TR><TD ALIGN="LEFT">PENNY</TD>
<TD ALIGN="RIGHT">0.038</TD>
<TD ALIGN="RIGHT">0.087</TD>
<TD ALIGN="RIGHT">15.93</TD>
</TR>
<TR><TD ALIGN="LEFT">DOLLOP</TD>
<TD ALIGN="RIGHT">0.134</TD>
<TD ALIGN="RIGHT">0.141</TD>
<TD ALIGN="RIGHT">0.233</TD>
</TR>
<TR><TD ALIGN="LEFT">DOLPENNY</TD>
<TD ALIGN="RIGHT">0.051</TD>
<TD ALIGN="RIGHT">0.241</TD>
<TD ALIGN="RIGHT">101.29</TD>
</TR>
<TR><TD ALIGN="LEFT">CLIQUE</TD>
<TD ALIGN="RIGHT">0.010</TD>
<TD ALIGN="RIGHT">0.015</TD>
<TD ALIGN="RIGHT">0.020</TD>
</TR>
</TABLE>
</DIV>

<P>
<BR>

<P>
In all cases the programs were run under the default options without compiler
switches, except as
specified here.   The
data sets used for the discrete characters programs have <TT>0</TT>'s and <TT>1</TT>'s
instead of <TT>A</TT>'s and <TT>C</TT>'s.  For CONTML the <TT>A</TT>'s and <TT>C</TT>'s
were made into <TT>0.0</TT>'s and <TT>1.0</TT>'s and considered as 40 2-allele loci.
For the distance programs 10  x  10 distance matrices were
computed from the three data sets.
For the restriction sites programs <TT>A</TT> and <TT>C</TT> were changed into
<TT>+</TT> and <TT>-</TT>.  It does not
make much sense to benchmark MOVE, DOLMOVE, or DNAMOVE, although when there
are many characters and many species the response time after each 
alteration of the tree should be proportional to the product of the number of
species and the number of characters.  For DNAML and DNAMLK the frequencies
of the four bases were
set to be equal rather than determined empirically as is the default.  For
RESTML the number of enzymes was set to 1.
<P>
In most cases, the benchmark was made more accurate by analyzing 10 data
sets using the <TT>M</TT> (Multiple data sets) option and dividing the resulting
time by 10.  Times were determined as user times using the Linux <TT>time</TT>
command.  Several patterns will be apparent from this.  The algorithms (MIX,
DOLLOP, CONTML, FITCH, KITSCH, PROTPARS, DNAPARS, DNACOMP, and
DNAML, DNAMLK, RESTML) that use the above-described addition strategy have
run times that do not depend strongly on the messiness of the data.  The only 
exception to this is that if a data set such as the Random data requires
extra rounds of global rearrangements it takes longer.  The
programs differ greatly in run time: the likelihood programs RESTML, DNAML and
CONTML are quite a bit slower than the others.  The protein sequence parsimony
program, which has to do a considerable amount of bookkeeping to keep track of
which amino acids can mutate to each other, is also relatively slow.
<P>
Another class of algorithms includes PENNY, DOLPENNY, DNAPENNY and CLIQUE.
These are branch-and-bound methods: in principle they should have execution
times that rise exponentially with the number of species and/or
characters, and they might be much more sensitive to messy data.  This is
apparent with PENNY, DOLPENNY, and DNAPENNY, which go from being reasonably
fast with clean data to very slow with messy data.  DOLPENNY is particularly
slow on messy data - this is because this algorithm cannot make use of some of
the lower-bound calculations that are possible with DNAPENNY and PENNY.  CLIQUE
is very fast on all
data sets.  Although in theory it should bog down if the number of cliques in
the data is very large, that does not happen with random data, which in
fact has few cliques and those small ones.  Apparently the "worst-case"
data sets that cause exponential run time are much rarer for CLIQUE than for
the other branch-and-bound methods.
<P>
NEIGHBOR is quite fast compared to FITCH and KITSCH, and should make it
possible to run much larger cases, although the results are expected to be
a bit rougher than with those programs.
<BR>
<P>
<H3>Speed with different numbers of species</H3>
<P>
How will the speed depend on the number of species and the number
of characters?  For the sequential-addition algorithms, the speed should
be proportional to somewhere between the cube of the number of species and
the square of the number of species, and to the number
of characters.  Thus a case that has, instead of 10 species and 20
characters, 20 species and 50 characters would take (in the cubic case)
2  x  2  x  2  x  2.5 = 20
times as long.  This implies that cases with more than 20 species will
be slow, and cases with more than 40 species <I>very</I> slow.  This places a
premium on working on small subproblems rather than just dumping a whole
large data set into the programs.
<P>
An exception to these rules will be some of the DNA programs that use an
aliasing device to save execution time.  In these programs execution time
will not necessarily increase proportional to the number of sites,
as sites that show the same pattern of nucleotides will be detected
as identical and the calculations for them will be done only once, which does
not lead to more execution time.  This is particularly
likely to happen with few species and many sites, or with data sets that have
small amounts of evolutionary divergence.
<P>
For programs FITCH and KITSCH, the distance matrix is square, so
that when we double the number of species we also double the number of
"characters", so that running times will go up as the fourth power of
the number of species rather than the third power.  Thus a 20-species
case with FITCH is expected to run sixteen times more slowly than a 10-species
case.
<P>
For programs like PENNY and CLIQUE the run times will rise faster
than the cube of the number of species (in fact, they can rise faster
than any power since these algorithms are not guaranteed to work in
polynomial time).  In practice, PENNY will frequently bog down above 11
species, while CLIQUE easily deals with larger numbers.
<P>
For NEIGHBOR the speed should vary only as the square of the number of
species, so a case twice as large will take only four times as long.  This
will make it an attractive alternative to FITCH and KITSCH for large data
sets.
<P>
<B>Note:</B> If you are unsure of how long a program will take, try it first on
a few species, then work your way up until you get a feel for the speed
and for what size programs you can afford to run.
<P>
Execution time is not the most important criterion for a program,
particularly as computer time gets much cheaper than your time or a
programmer's time.  With workstations on which background jobs can be run
all night, execution speed is not overwhelmingly relevant.  Some of us have been
conditioned by an earlier era of computing to consider execution speed
paramount.  But ease of use, ease of adaptation to your computer system,
and ease of modification are much more important in practice, and in
these respects I think these programs are adequate.  Only if you are
engaged in 1960's style mainframe computing, or if you have very large
amounts of data is minimization of execution
time paramount.
<P>
Nevertheless it would have been nice to have made the programs
faster.  The present speeds are a compromise between speed and
effectiveness: by making them slower and trying more rearrangements in the 
trees, or by enumerating all possible trees, I could have made the programs
more likely to find the best tree.  By trying fewer rearrangements I
could have speeded them up, but at the cost of finding worse trees.  I
could also have speeded them up by writing critical sections in assembly
language, but this would have sacrificed ease of distribution to new
computer systems.  There are also some options included in these programs that
make it 
harder to adopt some of the economies of bookkeeping that make other programs 
faster.  However to some extent I have simply made the decision not to spend 
time trying to speed up program bookkeeping when there were new likelihood and 
statistical methods to be developed.
<BR>
<P>
<H3>Relative speed of different machines</H3>
<P>
It is interesting to compare different machines using DNAPARS as the
standard task.  One can rate a machine on the DNAPARS benchmark by summing the
times for all three of the data sets.  Here are relative total timings over 
all three data sets (done with various versions of DNAPARS) for some machines,
taking a Pentium MMX 266 notebook computer running Linux with gcc as the
standard.  Benchmarks from versions 3.4 and 3.5 of the program are
included (respectively the Pascal and C versions whose timings are in
parentheses.  They are compared only with each other and are scaled to the
rest of the timings using the joint runs on the 386SX and the Pentium MMX 266.
This use of separate standards is necessary not
because of different languages but because different versions of the package
are being compared.  Thus, the "Time" is the ratio of the Total to that for
the Pentium, adjusted by the scalings of machines using 3.4 and 3.5 when
appropriate.  The Relative Speed is the reciprocal of the Time.
<P>
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT"><B>Machine</B></TD>
<TD ALIGN="LEFT"><B>Operating<BR>System</B></TD>
<TD ALIGN="LEFT"><B>Compiler</B></TD>
<TD ALIGN="LEFT"><B>Total</B></TD>
<TD ALIGN="LEFT"><B>Time</B></TD>
<TD ALIGN="LEFT"><B>Relative<BR>Speed</B></TD>
</TR>
<TR><TD ALIGN="LEFT">Toshiba T1100+</TD>
<TD ALIGN="LEFT">MSDOS</TD>
<TD ALIGN="LEFT">Turbo Pascal 3.01A</TD>
<TD ALIGN="LEFT">(269)</TD>
<TD ALIGN="LEFT">1758.2</TD>
<TD ALIGN="LEFT">0.0005688</TD>
</TR>
<TR><TD ALIGN="LEFT">Apple Mac Plus</TD>
<TD ALIGN="LEFT">MacOS</TD>
<TD ALIGN="LEFT">Lightspeed Pascal 2</TD>
<TD ALIGN="LEFT">(175.84)</TD>
<TD ALIGN="LEFT">1149.3</TD>
<TD ALIGN="LEFT">0.0008701</TD>
</TR>
<TR><TD ALIGN="LEFT">Toshiba T1100+</TD>
<TD ALIGN="LEFT">MSDOS</TD>
<TD ALIGN="LEFT">Turbo Pascal 5.0</TD>
<TD ALIGN="LEFT">(162)</TD>
<TD ALIGN="LEFT">1058.9</TD>
<TD ALIGN="LEFT">0.0009443</TD>
</TR>
<TR><TD ALIGN="LEFT">Macintosh Classic</TD>
<TD ALIGN="LEFT">MacOS</TD>
<TD ALIGN="LEFT">Think Pascal 3</TD>
<TD ALIGN="LEFT">(160)</TD>
<TD ALIGN="LEFT">1045.8</TD>
<TD ALIGN="LEFT">0.0009562</TD>
</TR>
<TR><TD ALIGN="LEFT">Macintosh Classic</TD>
<TD ALIGN="LEFT">MacOS</TD>
<TD ALIGN="LEFT">Think C</TD>
<TD ALIGN="LEFT">(43.0)</TD>
<TD ALIGN="LEFT">795.6</TD>
<TD ALIGN="LEFT">0.0012569</TD>
</TR>
<TR><TD ALIGN="LEFT">IBM PS2/60</TD>
<TD ALIGN="LEFT">MSDOS</TD>
<TD ALIGN="LEFT">Turbo Pascal 5.0</TD>
<TD ALIGN="LEFT">(58.76)</TD>
<TD ALIGN="LEFT">384.00</TD>
<TD ALIGN="LEFT">0.002604</TD>
</TR>
<TR><TD ALIGN="LEFT">80286 (12 Mhz)</TD>
<TD ALIGN="LEFT">MSDOS</TD>
<TD ALIGN="LEFT">Turbo Pascal 5.0</TD>
<TD ALIGN="LEFT">(47.09)</TD>
<TD ALIGN="LEFT">307.77</TD>
<TD ALIGN="LEFT">0.003249</TD>
</TR>
<TR><TD ALIGN="LEFT">Apple Mac IIcx</TD>
<TD ALIGN="LEFT">MacOS</TD>
<TD ALIGN="LEFT">Think Pascal 3</TD>
<TD ALIGN="LEFT">(42)</TD>
<TD ALIGN="LEFT">274.44</TD>
<TD ALIGN="LEFT">0.003644</TD>
</TR>
<TR><TD ALIGN="LEFT">Apple Mac SE/30</TD>
<TD ALIGN="LEFT">MacOS</TD>
<TD ALIGN="LEFT">Think Pascal 3</TD>
<TD ALIGN="LEFT">(42)</TD>
<TD ALIGN="LEFT">274.44</TD>
<TD ALIGN="LEFT">0.003644</TD>
</TR>
<TR><TD ALIGN="LEFT">Apple Mac IIcx</TD>
<TD ALIGN="LEFT">MacOS</TD>
<TD ALIGN="LEFT">Lightspeed Pascal 2</TD>
<TD ALIGN="LEFT">(39.84)</TD>
<TD ALIGN="LEFT">260.44</TD>
<TD ALIGN="LEFT">0.003840</TD>
</TR>
<TR><TD ALIGN="LEFT">Apple Mac IIcx</TD>
<TD ALIGN="LEFT">MacOS</TD>
<TD ALIGN="LEFT">Lightspeed Pascal 2#</TD>
<TD ALIGN="LEFT">(39.69)</TD>
<TD ALIGN="LEFT">259.33</TD>
<TD ALIGN="LEFT">0.003856</TD>
</TR>
<TR><TD ALIGN="LEFT">Zenith Z386 (16MHz)</TD>
<TD ALIGN="LEFT">MSDOS</TD>
<TD ALIGN="LEFT">Turbo Pascal 5.0</TD>
<TD ALIGN="LEFT">(38.27)</TD>
<TD ALIGN="LEFT">256.67</TD>
<TD ALIGN="LEFT">0.003896</TD>
</TR>
<TR><TD ALIGN="LEFT">Macintosh SE/30</TD>
<TD ALIGN="LEFT">MacOS</TD>
<TD ALIGN="LEFT">Think C</TD>
<TD ALIGN="LEFT">(13.6)</TD>
<TD ALIGN="LEFT">251.56</TD>
<TD ALIGN="LEFT">0.003975</TD>
</TR>
<TR><TD ALIGN="LEFT">386SX (16 MHz)</TD>
<TD ALIGN="LEFT">MSDOS</TD>
<TD ALIGN="LEFT">Turbo Pascal 6.0</TD>
<TD ALIGN="LEFT">(34)</TD>
<TD ALIGN="LEFT">222.41</TD>
<TD ALIGN="LEFT">0.004496</TD>
</TR>
<TR><TD ALIGN="LEFT">386SX (16 MHz)</TD>
<TD ALIGN="LEFT">MSDOS</TD>
<TD ALIGN="LEFT">Microsoft Quick C</TD>
<TD ALIGN="LEFT">(12.01)</TD>
<TD ALIGN="LEFT">222.41</TD>
<TD ALIGN="LEFT">0.004496</TD>
</TR>
<TR><TD ALIGN="LEFT">Sequent-S81</TD>
<TD ALIGN="LEFT">DYNIX</TD>
<TD ALIGN="LEFT">Silicon Valley Pascal</TD>
<TD ALIGN="LEFT">(13.0)</TD>
<TD ALIGN="LEFT">84.89</TD>
<TD ALIGN="LEFT">0.011780</TD>
</TR>
<TR><TD ALIGN="LEFT">VAX 11/785</TD>
<TD ALIGN="LEFT">Unix</TD>
<TD ALIGN="LEFT">Berkeley Pascal</TD>
<TD ALIGN="LEFT">(11.9)</TD>
<TD ALIGN="LEFT">77.77</TD>
<TD ALIGN="LEFT">0.012857</TD>
</TR>
<TR><TD ALIGN="LEFT">80486-33</TD>
<TD ALIGN="LEFT">MSDOS</TD>
<TD ALIGN="LEFT">Turbo Pascal 6.0</TD>
<TD ALIGN="LEFT">(11.46)</TD>
<TD ALIGN="LEFT">74.89</TD>
<TD ALIGN="LEFT">0.013353</TD>
</TR>
<TR><TD ALIGN="LEFT">Sun 3/60</TD>
<TD ALIGN="LEFT">SunOS</TD>
<TD ALIGN="LEFT">Sun C</TD>
<TD ALIGN="LEFT">(3.93)</TD>
<TD ALIGN="LEFT">72.67</TD>
<TD ALIGN="LEFT">0.013761</TD>
</TR>
<TR><TD ALIGN="LEFT">NeXT Cube (68030)</TD>
<TD ALIGN="LEFT">Mach</TD>
<TD ALIGN="LEFT">Gnu C</TD>
<TD ALIGN="LEFT">(2.608)</TD>
<TD ALIGN="LEFT">48.256</TD>
<TD ALIGN="LEFT">0.02072</TD>
</TR>
<TR><TD ALIGN="LEFT">Sequent S-81</TD>
<TD ALIGN="LEFT">DYNIX</TD>
<TD ALIGN="LEFT">Sequent Symmetry C</TD>
<TD ALIGN="LEFT">(2.604)</TD>
<TD ALIGN="LEFT">48.182</TD>
<TD ALIGN="LEFT">0.02075</TD>
</TR>
<TR><TD ALIGN="LEFT">VAXstation 3500</TD>
<TD ALIGN="LEFT">Unix</TD>
<TD ALIGN="LEFT">Berkeley Pascal</TD>
<TD ALIGN="LEFT">(7.3)</TD>
<TD ALIGN="LEFT">47.777</TD>
<TD ALIGN="LEFT">0.02093</TD>
</TR>
<TR><TD ALIGN="LEFT">Sequent S-81</TD>
<TD ALIGN="LEFT">DYNIX</TD>
<TD ALIGN="LEFT">Berkeley Pascal</TD>
<TD ALIGN="LEFT">(5.6)</TD>
<TD ALIGN="LEFT">36.600</TD>
<TD ALIGN="LEFT">0.02732</TD>
</TR>
<TR><TD ALIGN="LEFT">Unisys 7000/40</TD>
<TD ALIGN="LEFT">Unix</TD>
<TD ALIGN="LEFT">Berkeley Pascal</TD>
<TD ALIGN="LEFT">(5.24)</TD>
<TD ALIGN="LEFT">34.244</TD>
<TD ALIGN="LEFT">0.02920</TD>
</TR>
<TR><TD ALIGN="LEFT">VAX 8600</TD>
<TD ALIGN="LEFT">VMS</TD>
<TD ALIGN="LEFT">DEC VAX Pascal</TD>
<TD ALIGN="LEFT">(3.96)</TD>
<TD ALIGN="LEFT">25.889</TD>
<TD ALIGN="LEFT">0.03863</TD>
</TR>
<TR><TD ALIGN="LEFT">Sun SPARC IPX</TD>
<TD ALIGN="LEFT">SunOS</TD>
<TD ALIGN="LEFT">Gnu C version 2.1</TD>
<TD ALIGN="LEFT">(1.28)</TD>
<TD ALIGN="LEFT">23.689</TD>
<TD ALIGN="LEFT">0.04221</TD>
</TR>
<TR><TD ALIGN="LEFT">VAX 6000-530</TD>
<TD ALIGN="LEFT">VMS</TD>
<TD ALIGN="LEFT">DEC C</TD>
<TD ALIGN="LEFT">(0.858)</TD>
<TD ALIGN="LEFT">15.867</TD>
<TD ALIGN="LEFT">0.06303</TD>
</TR>
<TR><TD ALIGN="LEFT">VAXstation 4000</TD>
<TD ALIGN="LEFT">VMS</TD>
<TD ALIGN="LEFT">DEC C</TD>
<TD ALIGN="LEFT">(0.809)</TD>
<TD ALIGN="LEFT">14.978</TD>
<TD ALIGN="LEFT">0.06677</TD>
</TR>
<TR><TD ALIGN="LEFT">IBM RS/6000 540</TD>
<TD ALIGN="LEFT">AIX</TD>
<TD ALIGN="LEFT">XLP Pascal</TD>
<TD ALIGN="LEFT">(2.276)</TD>
<TD ALIGN="LEFT">14.866</TD>
<TD ALIGN="LEFT">0.06726</TD>
</TR>
<TR><TD ALIGN="LEFT">NeXTstation(040/25)</TD>
<TD ALIGN="LEFT">Mach</TD>
<TD ALIGN="LEFT">Gnu C</TD>
<TD ALIGN="LEFT">(0.75)</TD>
<TD ALIGN="LEFT">13.867</TD>
<TD ALIGN="LEFT">0.07212</TD>
</TR>
<TR><TD ALIGN="LEFT">Sun SPARC IPX</TD>
<TD ALIGN="LEFT">SunOS</TD>
<TD ALIGN="LEFT">Sun C</TD>
<TD ALIGN="LEFT">(0.68)</TD>
<TD ALIGN="LEFT">12.580</TD>
<TD ALIGN="LEFT">0.07951</TD>
</TR>
<TR><TD ALIGN="LEFT">486DX (33 MHz)</TD>
<TD ALIGN="LEFT">Linux</TD>
<TD ALIGN="LEFT">Gnu C #</TD>
<TD ALIGN="LEFT">(0.63)</TD>
<TD ALIGN="LEFT">11.666</TD>
<TD ALIGN="LEFT">0.08571</TD>
</TR>
<TR><TD ALIGN="LEFT">Sun SPARCstation-1</TD>
<TD ALIGN="LEFT">Unix</TD>
<TD ALIGN="LEFT">Sun Pascal</TD>
<TD ALIGN="LEFT">(1.7)</TD>
<TD ALIGN="LEFT">11.111</TD>
<TD ALIGN="LEFT">0.09000</TD>
</TR>
<TR><TD ALIGN="LEFT">DECstation 5000/200</TD>
<TD ALIGN="LEFT">Unix</TD>
<TD ALIGN="LEFT">DEC Ultrix C</TD>
<TD ALIGN="LEFT">(0.45)</TD>
<TD ALIGN="LEFT">8.333</TD>
<TD ALIGN="LEFT">0.12000</TD>
</TR>
<TR><TD ALIGN="LEFT">Sun SPARC 1+</TD>
<TD ALIGN="LEFT">SunOS</TD>
<TD ALIGN="LEFT">Sun C</TD>
<TD ALIGN="LEFT">(0.40)</TD>
<TD ALIGN="LEFT">7.400</TD>
<TD ALIGN="LEFT">0.13513</TD>
</TR>
<TR><TD ALIGN="LEFT">DECstation 3100</TD>
<TD ALIGN="LEFT">Unix</TD>
<TD ALIGN="LEFT">DEC Ultrix Pascal</TD>
<TD ALIGN="LEFT">(0.77)</TD>
<TD ALIGN="LEFT">5.022</TD>
<TD ALIGN="LEFT">0.1991</TD>
</TR>
<TR><TD ALIGN="LEFT">IBM 3090-300E</TD>
<TD ALIGN="LEFT">AIX</TD>
<TD ALIGN="LEFT">Metaware High C</TD>
<TD ALIGN="LEFT">(0.27)</TD>
<TD ALIGN="LEFT">5.000</TD>
<TD ALIGN="LEFT">0.2000</TD>
</TR>
<TR><TD ALIGN="LEFT">DECstation 5000/125</TD>
<TD ALIGN="LEFT">Unix</TD>
<TD ALIGN="LEFT">DEC Ultrix C</TD>
<TD ALIGN="LEFT">(0.267)</TD>
<TD ALIGN="LEFT">4.933</TD>
<TD ALIGN="LEFT">0.2027</TD>
</TR>
<TR><TD ALIGN="LEFT">DECstation 5000/200</TD>
<TD ALIGN="LEFT">Unix</TD>
<TD ALIGN="LEFT">DEC Ultrix C</TD>
<TD ALIGN="LEFT">(0.256)</TD>
<TD ALIGN="LEFT">4.733</TD>
<TD ALIGN="LEFT">0.2113</TD>
</TR>
<TR><TD ALIGN="LEFT">Sun SPARC 4/50</TD>
<TD ALIGN="LEFT">SunOS</TD>
<TD ALIGN="LEFT">Sun C</TD>
<TD ALIGN="LEFT">(0.249)</TD>
<TD ALIGN="LEFT">4.607</TD>
<TD ALIGN="LEFT">0.2171</TD>
</TR>
<TR><TD ALIGN="LEFT">DEC 3000/400 AXP</TD>
<TD ALIGN="LEFT">Unix</TD>
<TD ALIGN="LEFT">DEC C</TD>
<TD ALIGN="LEFT">(0.224)</TD>
<TD ALIGN="LEFT">4.144</TD>
<TD ALIGN="LEFT">0.2413</TD>
</TR>
<TR><TD ALIGN="LEFT">DECstation 5000/240</TD>
<TD ALIGN="LEFT">Unix</TD>
<TD ALIGN="LEFT">DEC Ultrix C</TD>
<TD ALIGN="LEFT">(0.1889)</TD>
<TD ALIGN="LEFT">3.496</TD>
<TD ALIGN="LEFT">0.2861</TD>
</TR>
<TR><TD ALIGN="LEFT">SGI Iris R4000</TD>
<TD ALIGN="LEFT">Unix</TD>
<TD ALIGN="LEFT">SGI C</TD>
<TD ALIGN="LEFT">(0.184)</TD>
<TD ALIGN="LEFT">3.404</TD>
<TD ALIGN="LEFT">0.2937</TD>
</TR>
<TR><TD ALIGN="LEFT">IBM 3090-300E</TD>
<TD ALIGN="LEFT">VM</TD>
<TD ALIGN="LEFT">Pascal VS</TD>
<TD ALIGN="LEFT">(0.464)</TD>
<TD ALIGN="LEFT">3.022</TD>
<TD ALIGN="LEFT">0.3309</TD>
</TR>
<TR><TD ALIGN="LEFT">DECstation 5000/200</TD>
<TD ALIGN="LEFT">Unix</TD>
<TD ALIGN="LEFT">DEC Ultrix Pascal</TD>
<TD ALIGN="LEFT">(0.39)</TD>
<TD ALIGN="LEFT">2.533</TD>
<TD ALIGN="LEFT">0.3947</TD>
</TR>
<TR><TD ALIGN="LEFT">Pentium 120</TD>
<TD ALIGN="LEFT">Linux</TD>
<TD ALIGN="LEFT">Gnu C</TD>
<TD ALIGN="LEFT">1.848</TD>
<TD ALIGN="LEFT">1.994</TD>
<TD ALIGN="LEFT">0.5016</TD>
</TR>
<TR><TD ALIGN="LEFT">Pentium Pro 180</TD>
<TD ALIGN="LEFT">Linux</TD>
<TD ALIGN="LEFT">Gnu C</TD>
<TD ALIGN="LEFT">1.009</TD>
<TD ALIGN="LEFT">1.088</TD>
<TD ALIGN="LEFT">0.9353</TD>
</TR>
<TR><TD ALIGN="LEFT">Pentium 266 MMX</TD>
<TD ALIGN="LEFT">Linux</TD>
<TD ALIGN="LEFT">Gnu C (PHYLIP 3.5)</TD>
<TD ALIGN="LEFT">(0.054)</TD>
<TD ALIGN="LEFT">1.0</TD>
<TD ALIGN="LEFT">1.0</TD>
</TR>
<TR><TD ALIGN="LEFT">Pentium 266 MMX</TD>
<TD ALIGN="LEFT">Linux</TD>
<TD ALIGN="LEFT">Gnu C</TD>
<TD ALIGN="LEFT">0.927</TD>
<TD ALIGN="LEFT">1.0</TD>
<TD ALIGN="LEFT">1.0</TD>
</TR>
<TR><TD ALIGN="LEFT">Pentium 200</TD>
<TD ALIGN="LEFT">Linux</TD>
<TD ALIGN="LEFT">Gnu C</TD>
<TD ALIGN="LEFT">0.853</TD>
<TD ALIGN="LEFT">0.9202</TD>
<TD ALIGN="LEFT">1.2647</TD>
</TR>
<TR><TD ALIGN="LEFT">SGI PowerChallenge</TD>
<TD ALIGN="LEFT">Irix</TD>
<TD ALIGN="LEFT">Gnu C</TD>
<TD ALIGN="LEFT">0.844</TD>
<TD ALIGN="LEFT">0.9297</TD>
<TD ALIGN="LEFT">1.0756</TD>
</TR>
<TR><TD ALIGN="LEFT">DEC Alpha 400 4/233</TD>
<TD ALIGN="LEFT">DUNIX</TD>
<TD ALIGN="LEFT">Digital C (cc -fast)</TD>
<TD ALIGN="LEFT">0.730</TD>
<TD ALIGN="LEFT">0.7875</TD>
<TD ALIGN="LEFT">1.2699</TD>
</TR>
<TR><TD ALIGN="LEFT">Pentium II 500</TD>
<TD ALIGN="LEFT">Linux</TD>
<TD ALIGN="LEFT">Gnu C</TD>
<TD ALIGN="LEFT">0.368</TD>
<TD ALIGN="LEFT">0.4053</TD>
<TD ALIGN="LEFT">2.467</TD>
</TR>
<TR><TD ALIGN="LEFT">Compaq/Digital Alpha 500au</TD>
<TD ALIGN="LEFT">DUNIX</TD>
<TD ALIGN="LEFT">Digital C (cc -fast)</TD>
<TD ALIGN="LEFT">0.167</TD>
<TD ALIGN="LEFT">0.1805</TD>
<TD ALIGN="LEFT">5.541</TD>
</TR>
</TABLE>
</DIV>
<P>
This benchmark not only reflects integer performance of these machines
(as DNAPARS has few floating-point operations) but also the efficiency
of the compilers.  Some of the machines (the DEC 3000/400 AXP
and the IBM RS/6000, in particular) are much faster than this benchmark
would indicate.  The numerical programs benchmark below gives them a
fairer test.  The Compaq/Digital Alpha 500au times are exaggerated because,
although their compiles are optimized for that processor, the Pentium
compiles are not similarly optimized.
<P>
Note that parallel machines like the Sequent and the SGI PowerChallenge are not
really as slow as indicated by the data here, as these runs did nothing to take
advantage of their parallelism.
<P>
These benchmarks have now extended over 13 years, and in the DNAPARS
benchmark they extend over a range of 8000-fold in speed!
The experience of our laboratory, which seems typical, is that
computer power grows by a factor of about 1.85 per year.  This is
roughly consistent with these benchmarks.
<P>
For a picture of speeds for a more numerically intensive program,
here are benchmarks using DNAML, with the Pentium MMX 266
as the standard.  Some of the timings, the ones in parentheses, are
using PHYLIP version 3.5, and those are compared to that version run on
the Pentium 266.  Runs using the PHYLIP 3.4 Pascal version are adjusted
using the 386SX timings where both were run.  Numbers are
total run times (total user time in the case of Unix) over all three data sets.
<P>
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT"><B>Machine</B></TD>
<TD ALIGN="LEFT"><B>Operating<BR>System</B></TD>
<TD ALIGN="LEFT"><B>Compiler</B></TD>
<TD ALIGN="RIGHT"><B>Seconds</B></TD>
<TD ALIGN="LEFT"><B>Time</B></TD>
<TD ALIGN="RIGHT"><B>Relative<BR>Speed</B></TD>
</TR>
<TR><TD ALIGN="LEFT">386SX 16 Mhz</TD>
<TD ALIGN="LEFT">PCDOS</TD>
<TD ALIGN="LEFT">Turbo Pascal 6</TD>
<TD ALIGN="RIGHT">(7826)</TD>
<TD ALIGN="LEFT"> 181.18</TD>
<TD ALIGN="RIGHT">0.005519</TD>
</TR>
<TR><TD ALIGN="LEFT">386SX 16 Mhz</TD>
<TD ALIGN="LEFT">PCDOS</TD>
<TD ALIGN="LEFT">Quick C</TD>
<TD ALIGN="RIGHT">(6549.79)</TD>
<TD ALIGN="LEFT"> 181.18</TD>
<TD ALIGN="RIGHT">0.005519</TD>
</TR>
<TR><TD ALIGN="LEFT">Compudyne 486DX/33</TD>
<TD ALIGN="LEFT">Linux</TD>
<TD ALIGN="LEFT">Gnu C</TD>
<TD ALIGN="RIGHT">(1599.9)</TD>
<TD ALIGN="LEFT"> 44.26</TD>
<TD ALIGN="RIGHT">0.022595</TD>
</TR>
<TR><TD ALIGN="LEFT">SUN Sparcstation 1+</TD>
<TD ALIGN="LEFT">SunOS</TD>
<TD ALIGN="LEFT">Sun C</TD>
<TD ALIGN="RIGHT">(1402.8)</TD>
<TD ALIGN="LEFT"> 38.805</TD>
<TD ALIGN="RIGHT">0.025770</TD>
</TR>
<TR><TD ALIGN="LEFT">Everex STEP 386/20</TD>
<TD ALIGN="LEFT">PCDOS</TD>
<TD ALIGN="LEFT">Turbo Pascal 5.5</TD>
<TD ALIGN="RIGHT">(1440.8)</TD>
<TD ALIGN="LEFT"> 33.356</TD>
<TD ALIGN="RIGHT"> 0.029980</TD>
</TR>
<TR><TD ALIGN="LEFT">486DX/33</TD>
<TD ALIGN="LEFT">PCDOS</TD>
<TD ALIGN="LEFT">Turbo C++</TD>
<TD ALIGN="RIGHT">(1107.2)</TD>
<TD ALIGN="LEFT"> 30.628</TD>
<TD ALIGN="RIGHT">0.032650</TD>
</TR>
<TR><TD ALIGN="LEFT">Compudyne 486DX/33</TD>
<TD ALIGN="LEFT">PCDOS</TD>
<TD ALIGN="LEFT">Waterloo C/386</TD>
<TD ALIGN="RIGHT">(1045.78)</TD>
<TD ALIGN="LEFT"> 28.929</TD>
<TD ALIGN="RIGHT">0.034567</TD>
</TR>
<TR><TD ALIGN="LEFT">Sun SPARCstation IPX</TD>
<TD ALIGN="LEFT">SunOS</TD>
<TD ALIGN="LEFT">Gnu C</TD>
<TD ALIGN="RIGHT"> (960.2)</TD>
<TD ALIGN="LEFT"> 26.562</TD>
<TD ALIGN="RIGHT">0.037648</TD>
</TR>
<TR><TD ALIGN="LEFT">NeXTstation(68040/25)</TD>
<TD ALIGN="LEFT">Mach</TD>
<TD ALIGN="LEFT">Gnu C</TD>
<TD ALIGN="RIGHT"> (916.6)</TD>
<TD ALIGN="LEFT"> 25.355</TD>
<TD ALIGN="RIGHT">0.039439</TD>
</TR>
<TR><TD ALIGN="LEFT">486DX/33</TD>
<TD ALIGN="LEFT">PCDOS</TD>
<TD ALIGN="LEFT">Waterloo C/386</TD>
<TD ALIGN="RIGHT"> (861.0)</TD>
<TD ALIGN="LEFT"> 23.817</TD>
<TD ALIGN="RIGHT">0.041986</TD>
</TR>
<TR><TD ALIGN="LEFT">Sun SPARCstation IPX</TD>
<TD ALIGN="LEFT">SunOS</TD>
<TD ALIGN="LEFT">Sun C</TD>
<TD ALIGN="RIGHT"> (787.7)</TD>
<TD ALIGN="LEFT"> 21.790</TD>
<TD ALIGN="RIGHT">0.045893</TD>
</TR>
<TR><TD ALIGN="LEFT">486DX/33</TD>
<TD ALIGN="LEFT">PCDOS</TD>
<TD ALIGN="LEFT">Gnu C</TD>
<TD ALIGN="RIGHT"> (650.9)</TD>
<TD ALIGN="LEFT"> 18.006</TD>
<TD ALIGN="RIGHT">0.05554</TD>
</TR>
<TR><TD ALIGN="LEFT">VAX 6000-530</TD>
<TD ALIGN="LEFT">VMS</TD>
<TD ALIGN="LEFT">DEC C</TD>
<TD ALIGN="RIGHT"> (637.0)</TD>
<TD ALIGN="LEFT"> 17.621</TD>
<TD ALIGN="RIGHT">0.05675</TD>
</TR>
<TR><TD ALIGN="LEFT">DECstation 5000/200</TD>
<TD ALIGN="LEFT">Unix</TD>
<TD ALIGN="LEFT">DEC Ultrix RISC C</TD>
<TD ALIGN="RIGHT"> (423.3)</TD>
<TD ALIGN="LEFT"> 11.710</TD>
<TD ALIGN="RIGHT">0.08540</TD>
</TR>
<TR><TD ALIGN="LEFT">IBM 3090-300E</TD>
<TD ALIGN="LEFT">AIX</TD>
<TD ALIGN="LEFT">Metaware High C</TD>
<TD ALIGN="RIGHT"> (201.8)</TD>
<TD ALIGN="LEFT">  5.582</TD>
<TD ALIGN="RIGHT">0.17914</TD>
</TR>
<TR><TD ALIGN="LEFT">Convex C240/1024</TD>
<TD ALIGN="LEFT">Unix</TD>
<TD ALIGN="LEFT">C</TD>
<TD ALIGN="RIGHT"> (101.6)</TD>
<TD ALIGN="LEFT">  2.8105</TD>
<TD ALIGN="RIGHT">0.35581</TD>
</TR>
<TR><TD ALIGN="LEFT">DEC 3000/400 AXP</TD>
<TD ALIGN="LEFT">Unix</TD>
<TD ALIGN="LEFT">DEC C</TD>
<TD ALIGN="RIGHT">  (98.29)</TD>
<TD ALIGN="LEFT">  2.7189</TD>
<TD ALIGN="RIGHT">0.36779</TD>
</TR>
<TR><TD ALIGN="LEFT">Pentium 120</TD>
<TD ALIGN="LEFT">Linux</TD>
<TD ALIGN="LEFT">Gnu C</TD>
<TD ALIGN="RIGHT">25.26</TD>
<TD ALIGN="LEFT">3.3906</TD>
<TD ALIGN="RIGHT">0.29493</TD>
</TR>
<TR><TD ALIGN="LEFT">Pentium Pro 180</TD>
<TD ALIGN="LEFT">Linux</TD>
<TD ALIGN="LEFT">Gnu C</TD>
<TD ALIGN="RIGHT">18.88</TD>
<TD ALIGN="LEFT">2.5342</TD>
<TD ALIGN="RIGHT">0.3946</TD>
</TR>
<TR><TD ALIGN="LEFT">Pentium 200</TD>
<TD ALIGN="LEFT">Linux</TD>
<TD ALIGN="LEFT">Gnu C</TD>
<TD ALIGN="RIGHT">16.51</TD>
<TD ALIGN="LEFT">2.2161</TD>
<TD ALIGN="RIGHT">0.4512</TD>
</TR>
<TR><TD ALIGN="LEFT">SGI PowerChallenge</TD>
<TD ALIGN="LEFT">IRIX</TD>
<TD ALIGN="LEFT">Gnu C</TD>
<TD ALIGN="RIGHT">12.446</TD>
<TD ALIGN="LEFT">1.6706</TD>
<TD ALIGN="RIGHT">0.5985</TD>
</TR>
<TR><TD ALIGN="LEFT">Pentium MMX 266</TD>
<TD ALIGN="LEFT">Linux</TD>
<TD ALIGN="LEFT">Gnu C (PHYLIP 3.5)</TD>
<TD ALIGN="RIGHT">(36.15)</TD>
<TD ALIGN="LEFT"> 1.0</TD>
<TD ALIGN="RIGHT"> 1.0</TD>
</TR>
<TR><TD ALIGN="LEFT">DEC Alpha 400 4/233</TD>
<TD ALIGN="LEFT">Linux</TD>
<TD ALIGN="LEFT">Gnu C (cc -fast)</TD>
<TD ALIGN="RIGHT">8.0418</TD>
<TD ALIGN="LEFT">1.0792</TD>
<TD ALIGN="RIGHT">0.9266</TD>
</TR>
<TR><TD ALIGN="LEFT">Pentium MMX 266</TD>
<TD ALIGN="LEFT">Linux</TD>
<TD ALIGN="LEFT">Gnu C</TD>
<TD ALIGN="RIGHT">7.45</TD>
<TD ALIGN="LEFT"> 1.0</TD>
<TD ALIGN="RIGHT"> 1.0</TD>
</TR>
<TR><TD ALIGN="LEFT">Pentium II 500</TD>
<TD ALIGN="LEFT">Linux</TD>
<TD ALIGN="LEFT">Gnu C</TD>
<TD ALIGN="RIGHT">6.02</TD>
<TD ALIGN="LEFT"> 0.8081</TD>
<TD ALIGN="RIGHT"> 1.2375</TD>
</TR>
<TR><TD ALIGN="LEFT">Compaq/Digital Alpha 500au</TD>
<TD ALIGN="LEFT">Linux</TD>
<TD ALIGN="LEFT">Gnu C (cc -fast)</TD>
<TD ALIGN="RIGHT">0.9383</TD>
<TD ALIGN="LEFT"> 0.1259</TD>
<TD ALIGN="RIGHT">7.940</TD>
</TR>
</TABLE>
</DIV>
<P>
As before, the parallel machines such as the Convex and the SGI PowerChallenge
were only run using one processor, which does not take into account the
gain that could be obtained by parallelizing the programs.  The speed of the
Compaq/Digital Alpha 500au is exaggerated because it was compiled in a way
optimized for its processor, while the Pentium compiles were not.
<P>
You are invited to send me figures for your machine for
inclusion in future tables.  Use the data sets above and compute the total
times for DNAPARS and for DNAML for the three data sets (setting the
frequencies of the four bases to 0.25 each for the DNAML runs).  Be sure to
tell me the name and version of your compiler, and the version of PHYLIP you
tested.
If the times are too small to be measured accurately, obtain the times
for ten data sets (the Multiple data sets option) and divide by 10.
<P>
<A NAME="comments"><HR><P></A>
<DIV ALIGN="CENTER">
<H2>General Comments on Adapting<BR>
the Package to Different Computer Systems</H2></DIV>
<P>
In the sections following you will find instructions on how to adapt the 
programs to different computers and compilers.  The programs should compile
without alteration on most versions of C.  They use the "malloc" library
or "calloc" function to allocate memory so that the upper limits on how many
species or how many sites or characters they can run is set by the system memory
available to that memory-allocation function.
<P>
In the document file for each program, I have supplied a small
input example, and the output it produces, to help you check whether the
programs are running properly.
<P>
<DIV ALIGN=CENTER>
<A NAME="compiling"><HR><P></A>
<H2>Compiling the programs</H2>
</DIV>
<P>
If you have not been able to get executables for PHYLIP, you should be
able to make your own.  This is easy under Unix and Linux, but more
difficult if you have a Macintosh or a Windows system.  If you have the
latter, we stringly recommend you download and use the PowerMac and
Windows executables that we distribute.  If you do that, you will not need
to have any compiler or to do any compiling.  I get a certain number of
inquiries each year from confused users who are not sure what a compiler
is but think they need one.  After downloading the executables they
contact me and complain that they did not find a compiler included in the
package, and would I please e-mail them the compiler.  What they really
need to do is use the executables and forget about compiling them.
<P>
Some users may also need to compile the programs in order to modify them.
The instructions below will help with this.
<P>
I will discuss how to compile PHYLIP using one of a number of widely-used
compilers.  After these I will comment on compiling PHYLIP on other, less
widely-used systems.
<P>
<H3>Unix and Linux</H3>
<P>
In Unix and Linux (which is Unix in all important functional respects, if
not in all
legal respects) it is easy to compile PHYLIP yourself, which is why we have
generally not bothered to distribute executables for Unix.  Unix (and Linux)
systems generally have a C compiler and have the <TT>make</TT> utility.  We
distribute with the PHYLIP source code a Unix-compatible <TT>Makefile</TT>.
<P>
After you have finished unpacking the Documentation and Source Code
archive, you will find that you have created a directory <TT>phylip</TT>
in which there are three
subdirectories, called <TT>exe</TT>, <TT>src</TT>, and <TT>doc</TT>.  
There is also an HTML web page, <TT>phylip.html</TT>.  The <TT>exe</TT>
directory
will be empty, <TT>src</TT> contains the source code files, including the
<TT>Makefile</TT>.  Directory <TT>doc</TT> contains the documentation files.
<P>
Enter the <TT>src</TT> directory.  Before you compile, you will want to
look at the makefile and see whether you want to alter the compilation
command.  There are careful instructions in the Makefile telling you how to
do this.  To compile all the programs just type:
<P>
<TT>make install</TT>
<P>
You will then see the compiling commands as they happen, with
occasional warning messages.  If these are warnings, rather than errors,
they are not too serious.  A typical warning would be like this:
<P>
<TT>dnaml.c:1204: warning: static declaration for re_move follows non-static</TT>
<P>
After a time the compiler will finish compiling.  If you have done a
<TT>make install</TT> the system will then move the executables into the
<TT>exe</TT> subdirectory and also save space by erasing all the relocatable
object files that were produced in the process.  You should be left with
useable executables in the <TT>exe</TT> directory, and the <TT>src</TT>
directory should be as before.   To run the executables, go into the
<TT>exe</TT> directory and type the program name (say <TT>dnaml</TT>).
The names of the
executables will be the same as the names of the C programs, but without the
<TT>.c</TT> suffix.  Thus <TT>dnaml.c</TT> compiles to make an executable called <TT>dnaml</TT>.
<P>
A typical Unix or Linux installation would put the directory <TT>phylip</TT>
in <TT>/usr/local</TT>.  The name of the executables directory <TT>EXEDIR</TT>
could be changed to be <TT>/usr/local/bin</TT>, so that the <TT>make install</TT>
command puts the executables there.  If the users have <TT>/usr/local/bin</TT>
in their paths, the programs would be found when their names are typed.
The font files <TT>font1</TT> through <TT>font6</TT> could also be
placed there.  A batch script containing the lines
<P>
<PRE>
      ln -s /usr/local/bin/font1 font1
      ln -s /usr/local/bin/font2 font2
      ln -s /usr/local/bin/font3 font3
      ln -s /usr/local/bin/font4 font4
      ln -s /usr/local/bin/font5 font5
      ln -s /usr/local/bin/font6 font6
</PRE>
<P>
could be used to establish links in the user's working directory so that
Drawtree and Drawgram would find these font files when users
type a name such as <TT>font1</TT> when the program asks
them for a font file name.  The
documentation web pages are in subdirectory <TT>doc</TT> of the
main PHYLIP directory, except for one, <TT>phylip.html</TT> which is
in the main PHYLIP directory.  It has a table of all of the documentation
pages, including this one.  If users create a bookmark to that page
it can be used to access all of the other documentation pages.
<P>
To compile just one program, such as DNAML, type:
<P>
<TT>make dnaml</TT>
<P>
After this compilation, <TT>dnaml</TT> will be in the <TT>src</TT>
subdirectory.  So will some rrelocatable object code files that
were used to create the executable.  These have names ending in
<TT>.o</TT> - they can safely be deleted.
<P>
If you have problems with the compilation command, you can edit the
<TT>Makefile</TT>.  It has careful explanations at its front of how you
might want to do so.  For example, you might want to change the C
compiler name <TT>cc</TT> to the name of the Gnu C compiler, <TT>gcc</TT>.
This can be done by removing the comment character <TT>#</TT> from the
front of one line, and placing it at the front of a nearby line.
How to do so should be clear from the material at the beginning of the
<TT>Makefile</TT>.  We have included sample lines for using the <TT>gcc</TT>
compiler and for using the Cygwin Gnu C++ environment on Windows, as
well as the default of <TT>cc</TT>.
<P>
Some older C compilers (notably the Berkeley C compiler which is
included free with some Sun systems) do not adhere to the ANSI C
standard (because they were written before it was set down).
They have trouble with the function prototypes which are in
our programs.  We have included an <TT>#ifndef</TT> preprocessor
command to eliminate the problem, if you use the switch <TT>-DOLDC</TT>
when compiling.  Thus with these compilers you need only use this in
your C flags (in the Makefile) and compilers such as Berkeley C
will cause no trouble. 
<P>
<H3>Macintosh PowerMacs</H3>
<P>
<B>Compiling with Metrowerks Codewarrior on Macintosh PowerMacs...</B>
<P>
We shall assume that you have a recent version of the Metrowerks
Codewarrior  C++
compiler.  This description, and the project files that we provide,
assume Codewarrior 5.3.  We also assume some familiarity with
the use of the Codewarrior compiler and its Integrated Development
Environment (IDE).
<P>
Start with our <TT>src</TT> directory (folder) that contains the C source
code files such as <TT>dnaml.c</TT> and also the Codewarrior resource
files such as <TT>dnaml.rsrc</TT>, which are provided by us.
<P>
<B>Creating the project file.</B>  We will use DnaML as our example.
We have provided a full set of project files in the
self-extracting Macintosh archive.
<EM>If you have them then you do not need
to do the items on the following list:</EM>
<OL>
<LI>Start up the Codewarrior IDE integrated development environment.
<LI>Create a new project file by choosing <TT>New...</TT> on the <TT>File</TT>
menu.
<LI>Type in the project name <TT>dnaml.proj</TT>
<LI>On the Project menu on the left side of the <TT>New</TT> window, double-click on <TT>MacOS C/C++ Stationery</TT>
<LI>In the <TT>New project</TT> window that opens, click on the triangle
to the left of <TT>Standard Console</TT>.
<LI>Move the slider at the right of the window down until you reach
<TT>SIOUX-WASTE</TT>
<LI>Click on the triangle to the left of <TT>SIOUX-WASTE</TT>.  This opens
another list of choices below.
<LI>Click on the menu item <TT>SIOUX-WASTE C PPC</TT>. Press the <TT>OK</TT> button.  After a bit a window <TT>dnaml.proj</TT> will open.
<LI>Click on the triangle to the left of the <TT>Sources</TT> menu item.  A
template item called <TT>HelloWorld.c</TT> will open.
<LI>Select <TT>HelloWorld.c</TT>.
<LI>Open the <TT>Edit</TT> menu at the top of the Mac screen and select
<TT>Clear</TT>.  A box will open asking if you want to remove <TT>HelloWorld.c</TT> from the project.
<LI>Select <TT>OK</TT>.
<LI>If the <TT>dnaml.c</TT> file came from the self-extracting Macintosh
archive that we distribute, it should show a yellow-and-back-striped Metrowerks
icon (if not, as when you get it from some other form of our distribution,
you may have to pass it through a program like Microsoft Word, making
sure to save it as a Text Only file, to get
Metrowerks to be able to see it as a potential source code file).
<LI>Drag the <TT>dnaml.c</TT> file onto the <TT>Sources</TT> item in your
<TT>dnaml.proj</TT> window.
<LI>Drop it onto Sources so that it appears under the <TT>Sources</TT> choice.
This may take a few tries -- if it appears above <TT>Sources</TT> grab it
and move it again.
<LI>Now add the other files that must be compiled with <TT>dnaml.c</TT>.
These can be identified by looking at our <TT>Makefile</TT> -- for DnaML
they are <TT>seq.c</TT>, <TT>phylip.c</TT>, <TT>seq.h</TT>, and <TT>phylip.h</TT>.  Each of them needs to be added to the project file in the same way that
<TT>dnaml.c</TT> was.
<LI>Drag <TT>dnaml.rsrc</TT> into <TT>Sources</TT> in the same way.  It
doesn't matter whether it appears before or after <TT>dnaml.c</TT>.
<LI>Go to the <TT>Edit</TT> menu and select the <TT>PPC Std C SIOUX-WASTE Settings</TT> item.  A window of that name will then open.
<LI>Under the <TT>Target</TT> item you will see a <TT>PPC Target</TT> item.
Select it.  A <TT>PPC Target</TT> window will open to the right.
<LI>Change the name in the <TT>File Name</TT> box to be <TT>PHYLIP</TT>
<LI>Change the <TT>????</TT> in the <TT>Creator</TT> box to (say) <TT>PHYD</TT>
<LI>Change the <TT>Preferred Heap Size</TT> to <TT>1024</TT>.
<! need to add selections of PPC Processor here >
<! ditto for Global Optimization >
<LI>Under <TT>Language Settings</TT> in the left-hand menu of the window,
select <TT>C/C++ Language</TT>.  A window called <TT>C/C++ Language</TT>
will open to the immediate right.
<LI>Click on <TT>Require Function Prototypes</TT> to deselect that setting.
<LI>Click on the <TT>Save</TT> button at the lower-right of the project
settings window.
<LI>Close the <TT>PPC Std C SIOUX-WASTE Settings</TT> window using the usual
box in the upper-left corner.
<LI>On your Desktop you should now find a folder <TT>PHYLIP</TT>.
If it has a
file called <TT>HelloWorld.c</TT> you may want to discard that file.
<LI>In that <TT>PHYLIP</TT> folder you will find a file <TT>dnaml.proj</TT>.
<LI>Double-click on that project file.  If the Metrowerks is not already open,
it should open now.
<LI>If a window called <TT>Project Messages</TT> opens and there is a
complaint in it about access paths being wrong, you should fix these by
selecting the <TT>Reset project entry paths</TT> item in the <TT>Project</TT>
menu.
<LI>Select the <TT>Make</TT> item in the <TT>Project</TT> menu.
<LI>In the <TT>Project</TT> menu, select <TT>Make</TT>
</OL>
<B>Compiling a program once its resource file is available.</B>.
If the resource files are all available (as they should be), you did not need
to do any of the above.   Usually users will have no need to compile
the programs, but occasionally they may want to change a setting or
add a feature.  In that case the Metrowerks Codewarrior compiler can be
used.  We have provided support for compiling the programs in its
most recent version, version 5.3.  The following discussion will
assume that you have obtained and installed the compiler.
<P>
You should find in the source code directory
<TT>src</TT> a subdirectory called <TT>mac</TT> which contains the
Metrowerks Codewarrior compiler "project files" (with names ending in
<TT>.proj</TT>, as well as the resource files (which end in <TT>.rsrc</TT>
for each program.  You can get into this subdirectory, activate the
Metrowerks compiler, and open the appropriate project file.  To
compile the program, simply make sure that the project file is an
active window, and type <TT>Command-M</TT> (which is to say, hold down
the <TT>Command</TT> key while typing <TT>M</TT>).  Alternatively,
pull down the <TT>Project</TT> window and select <TT>Make</TT>.  The
program should then compile, possibly with ignorable warning messages.
<P>
<H3>Windows systems</H3>
<P>
<B>Compiling with Microsoft Visual C++</B> 
<P>
Microsoft Visual C++ is used to compile the executables we distribute
Windows.  It can compile using a Makefile.  We have supplied this
in the source code distrubution as <TT>Makefile.msvc</TT>.
You will need to preserve the Unix Makefile by renaming it to, say,
<TT>Makefile.unix</TT>, then make a copy of <TT>Makefile.msvc</TT>
and call it <TT>Makefile</TT>. 
<P>
<B>Setting the path.</B>
Before using <TT>nmake</TT> you will need to have the paths
set properly.  For this, use the Start menu to open Command or
a Dos Prompt first.  To set the path type<BR>
<PRE>
set MSVC=Path
</PRE>
where Path is where Microsoft Visual Studio is installed 
(e.g. it might be in <TT>c:\Microsoft Visual Studio</TT>).
However the path you type should not have any spaces in it.
This means that you may have to use the directory's
DOS filename.  In general to get a DOS name you take the first six letters of 
the directory name and follow them by <TT>~1</TT>. For example,
<TT>Microsoft Visual Studio</TT> will have a DOS name 
<TT>Micros~1</TT>, <TT>Program Files</TT> will be <TT>Progra~1</TT>).
Depending on what other
file are in the directory the DOS name may be the first six letters followed
by <TT>~2,~3,~4</TT>, etc... (e.g. <TT>Micros~3</TT> or <TT>Progra~5</TT>).
It may take some
experimentation to figure it out. With older Versions of Windows (pre-win2000)
it may be possible to just right click on the directory icon and select 
Properties to get the DOS name.
<P>
Once you have set MSVC, type
<PRE>
PATH=%PATH%;%MSVC%\VC98\bin
</PRE>
Then the Makefile will need to be edited.  The line
<PRE>
MSVCPATH=c:\Micros~1\VC98
</PRE>
will need to be changed so that 
It points to whereever Microsoft Visual Studio is installed followed by
 <TT>\VC98</TT>. 
<P>
<B>Using the Makefile</B>. The Makefile is invoked using the
<TT>nmake</TT> command.  If you simply type <TT>nmake</TT> you
will get a list of possible <TT>make</TT> commands.  For example,
to compile a single program such as <TT>Dnaml</TT> but not
install it, type <TT>make dnaml</TT>.  To compile and install all
programs type <TT>make install</TT>.  We have supplied all the
support files and icons needed for the compilations.  They are
in subdirectory <TT>msvc</TT> of the main source code
directory.
<P>
<B>Compiling with Borland C++</B> 
<P>
Borland C++ can be downloaded for free from Inprise (Borland)
(see their site
<A HREF="http://www.borland.com">http://www.borland.com</A>
It can compile using a Makefile.  We have supplied this
in the source code distrubution as <TT>Makefile.bcc</TT>.
You will need to preserve the Unix Makefile by renaming it to, say,
<TT>Makefile.unix</TT>, then make a copy of <TT>Makefile.bcc</TT>
and call it <TT>Makefile</TT>.  The Makefile is invoked using the
<TT>make</TT> command.  If you simply type <TT>make</TT> you
will get a list of possible <TT>make</TT> commands.  For example,
to compile a single program such as <TT>Dnaml</TT> but not
install it, type <TT>make dnaml</TT>.  To compile and install all
programs type <TT>make install</TT>.  We have supplied all the
the support files and icons needed for the compilations.  They
are in subdirectory <TT>bcc</TT> of the main source code
directory.  We have had to supply a complete
second set of the resource files with names <TT>*.brc</TT>
because Borland resource files have a minor incompatibility
with Microsoft Visual C++ resource files.
<P>
If this does not work the <TT>PATH</TT> may need to be set manually. 
This can be done by opening a Command or DOS window using the Start
menu.  To set the path, type
<PRE>
set BORLAND=Path
</PRE>
Where <TT>Path</TT> is where Borland is installed, such as
<TT>C:\Progra~1\Borland</TT>.
Then type
<PRE>
PATH=%PATH%;%BORLAND%\CBUILD~1\Bin
</PRE>
<P>
<B>Compiling with Metrowerks Codewarrior for Windows</B> 
<P>
As with Macintosh systems, Metrowerks Codewarrior requires 
you to have project files for each program you compile.
For Metrowerks Codewarrior for Windows we are not providing the projects
themselves, but we are providing
projects which have been exported as XML files. To open one of these one
cannot just click on 
File/Open but instead on the menu option File/Import Project.
Metrowerks will then ask you for the project name.
Type in the name of the program (e.g. dnaml). Once this is done Metrowerks will
act like this is a regular project file.
<P>
We have supplied a complete set of these XML project files in the
source code distribution.  They are in subdirectory <TT>metro</TT>
of the main source code directory.  This is supplied with the
source code distribution for Windows (it is not in the source
code distributions for other platforms).
For Metrowerks Codewarrior for Windows we are not providing the projects
themselves, but we are providing
projects which have been exported as XML files. To open one of these one
cannot just click on
File/Open but instead on the menu option File/Import Project.
Metrowerks will then ask you for the project name.
Type in the name of the program (e.g. dnaml). Once this is done Metrowerks will
act like this is a regular project file.
<P>
To compile the program
pull down the <TT>Project</TT> menu and select <TT>Make</TT>.  The
program should then compile, possibly with ignorable warning messages.
<P>
For the moment we are not giving here the details of
how to create these projects yourself -- you usually will not need
to, as you have the project files we have supplied.
<P>
<B>Compiling with Cygnus Gnu C++</B>
<P>
Cygnus Solutions (now a part of Red Hat, Inc.) has adapted the Gnu C compiler
to Windows systems and
provided an environment, CygWin, which mimics Unix for compiling.
This is available for purchase from them, and they also make it
available to be downloaded for free.  The download is large.  To get it, go
to <A HREF="http://sources.redhat.com/cygwin/download.html">their download site</A> at
<CODE>http://sources.redhat.com/cygwin/download.html</CODE> and follow the
instructions there.  It is a bit
difficult to figure out how to download it -- you need to download
their <TT>setup.exe</TT> program and then it will download the rest
when it is run.  You will need a lot of disk space for it.
<P> 
Once you have
installed the free Cygnus environment and the associated Gnu C compiler
on your Windows system, compiling PHYLIP is essentially identical to
what one does for Unix or Linux.  In PHYLIP's <TT>src</TT> directory,
change the name of our Unix <TT>Makefile</TT> to something like
<TT>Makefile.unx</TT> (so as to keep it around).  There is a special
Makefile for the Cygwin
compiler called <TT>Makefile.cyg</TT>. Make a copy of it called
<TT>Makefile</TT>.
<P>
This Makefile should contain a compiling command:
<P>
<TT>CC = gcc</TT>
<P>
Now enter the Cygwin environment (which you can do using the Windows
<TT>Start</TT> menu and its <TT>Programs</TT> menu item.  There should be
a <TT>Cygnus</TT> menu choice within that submenu, which you can use to
start the Cygnus environment.  This puts you in an imitation of a Unix
shell.
<P>
On entering the CygWin environment you will find yourself in one of the
subdirectories of the CygWin directory.  Change to the directory where the
PHYLIP programs have been put (for example by issuing the command
<P>
<TT>cd c:/phylip</TT><BR>
<BR>
You should then be able to compile PHYLIP
by issuing the appropriate make command, such as <TT>make install</TT>.
If you have modified one of our source code files such as <TT>dnaml.c</TT>,
it would be wise to
have saved the original version of it first as, say, <TT>dnaml.c0</TT>.
To associate an icon with a program (say DnaML), you need an icon
file (say <TT>dna.ico</TT> which contains the icon in standard format.
There should also be a file called <TT>dnaml.rc</TT> which contains the single
line:
<P>
<TT>dnaml ICON "dna.ico"</TT>
<P>
We have provided a subdirectory <TT>icons</TT> in the <TT>src</TT>
subdirectory, containing a full set of icons and a full set of resource
files (<TT>*.rc</TT>).
Our Cygwin Makefile will automatically invoke them.
<P>
<H3>VMS VAX systems</H3>
<P>
We have not tried to compile version 3.6 on an OpenVMS system but the
following instructions should work.
On the OpenVMS operating system with DEC VAX VMS C the programs will compile
without alteration.  The commands for compiling a typical program
(DNAPARS, which depends on the separately compiled files <TT>phylip.c</TT>
and <TT>seq.c</TT>) are:
<P>
<TT>$ DEFINE LNK$LIBRARY SYS$LIBRARY:VAXCRTL
<BR>
$ CC DNAPARS.C
<BR>
$ CC PHYLIP.C
<BR>
$ CC SEQ.C
<BR>
$ LINK DNAPARS,PHYLIP,SEQ
<BR>
</TT>
<P>
Once you use this <TT>$ DEFINE</TT> statement during a given interactive session,
you need not repeat it again as the symbol <TT>LNK$LIBRARY</TT> is thereafter
properly defined.  The compilation process leaves a file <TT>DNAPARS.OBJ</TT>
in your directory: this can
be discarded.  The executable program is named <TT>DNAPARS.EXE</TT>.  To run the program
one then uses the command:
<P>
<TT>$ R DNAPARS</TT>
<P>
The compiler defaults to the filenames <TT>INFILE.</TT>, <TT>OUTFILE.</TT>, and
<TT>TREEFILE.</TT>.
If the input file <TT>INFILE.</TT> does not exist the program will prompt you to
type in its name.  Note that some commands on VMS such as <TT>TYPE OUTFILE</TT>
will fail because the name of the file that it will attempt to type out will be not
<TT>OUTFILE.</TT> but <TT>OUTFILE.LIS</TT>.  To get it to type the write file you
would have to instead issue the command <TT>TYPE OUTFILE.</TT>.
<P>
When you are
using the interactive previewing feature of DRAWGRAM (or DRAWTREE) on
a Tektronix or DEC ReGIS compatible terminal, you will want before
running the program to have issued the command:
<P>
<TT>$ SET TERM/NOWRAP/ESCAPE</TT>
<P>
so that you do not run into trouble from the VMS line length limit of
255 characters or the filtering of escape characters.
<P>
To know which files to compile together, look at the entries in the
<TT>Makefile</TT>.
<P>
VMS systems are rapidly disappearing, so we will not devote much
effort to get PHYLIP working on them.
<P>
<H3>Parallel computers</H3>
<P>
As parallel computers become more common, the issue of how to compile
PHYLIP for them has become more pressing.  People have been compiling
PHYLIP for vector machines and parallel machines for many years.  We
have not made a version for parallel machines because there is still
no standard parallel programming environment on such machines (or rather,
there are many standards, so that one cannot find one that makes
a parallel execution version of PHYLIP practical).  However the
MPI Message Passing Interface is spreading rapidly, and we will
probably support it in future versions of PHYLIP.
<P>
Although the underlying algorithms of most programs,
which treat sites independently, should be amenable to vector and
parallel processors,
there are details of the code which might best be changed.
In certain of the programs (<TT>Dnaml</TT>, <TT>Dnamlk</TT>,
<TT>Proml</TT>, <TT>Promlk</TT>) I have put a special
comment statement next to the loops in the program where
the program will spend most of its time, and which are the places
most likely to benefit from parallelization.  This comment statement is:<BR>
<PRE>
           /* parallelize here */
</PRE>
In particular
within these innermost loops of the programs there are often scalar quantities
that are used for temporary bookkeeping.  These quantities, such as
<TT>sum1, sum2, zz, z1, yy, y1, aa, bb, cc, sum,</TT> and <TT>denom</TT> in procedure makenewv
of DNAML (and similar quantities in procedure nuview) are there to
minimize the number of array references.  For vectorizing and parallelizing
compilers it will 
be better to replace them by arrays so that processing can occur
simultaneously. 
<P>
If you succeed in making a parallel version of PHYLIP we would like to
know how you did it.  In particular, if you can prepare a web page which
describes how to do it for your computer system, we would like to have it
for inclusion in our PHYLIP web pages.  Please e-mail it to me.  We hope to
have a set of pages that give detailed instructions on how to make parallel
version of PHYLIP on various kinds of machines.  Alternatively, if we
are given your modified version of the program we may be able to
figure out how to make modifications to our source code to allow
users to compile the program in a way which makes those modifications.
<P>
<H3>Other computer systems</H3>
<P>
As you can see from the variety of different systems on which these
programs have been successfully run, there are no serious
incompatibility problems with most computer systems.  PHYLIP in various
past Pascal versions has also been compiled on 8080 and Z80 CP/M Systems, Apple
II systems running UCSD Pascal, a variety of minicomputer systems such as
DEC PDP-11's and HP 1000's, on 1970's era mainframes such as CDC
Cyber systems, and so on.  In a later era
it was also compiled on IBM 370 mainframes, and of course on DOS and
Windows systems and on Macintosh and PowerMacintosh systems.
We have gradually
accumulated experience on a wider variety of C compilers.  If you succeed in
compiling the C version of PHYLIP on a different machine or a different
compiler, I would like to
hear the details so that I can consider including the instructions in a future version
of this manual.
<P>
<DIV ALIGN="CENTER">
<A NAME="FAQ"><HR><P></A>
<H2>Frequently Asked Questions</H2></DIV>
<P>
This set of Frequently Asked Questions, and their answers, is from the
PHYLIP web site.  A more up-to-date version can be found there, at:
<P>
<DIV ALIGN="CENTER">
<A HREF="http://evolution.gs.washington.edu/phylip/faq.html">
<TT>http://evolution.gs.washington.edu/phylip/faq.html</TT></A></DIV>
<P>
<DL>
<DT><STRONG>"It doesn't work! <I>It doesn't work!!</I> It says <TT>can't find infile.</TT></STRONG>
<DD>Actually, it's working just fine.  Many of the programs look for an input file called <TT>infile</TT>,
and if one of that name is not present in the current directory, they then ask
you to type in the name of the input file.  That's all that it's doing. This
is done so that
you can get the program to read the file without you having to type in its
name, by making a copy of your input file and calling it <TT>infile</TT>.
If you don't do that, then the program issues this message.  It looks
alarming, but really all that it is trying to do is to get you to type in
the name of the input file.  Try giving it the name of the input file.
<DT><STRONG>"The program reads my data file and then says it's has
a memory allocation error!"</STRONG>
<DD>This is what tends to happen if there is a problem with the format of the data
file, so that the programs get confused and think they need to set aside memory
for 1,000,000 species or so.  The result is a "memory allocation error".  Check the data file format against the documentation:
make sure that the data files have <I>not</I> been saved in the format of
your word processor (such as Microsoft Word) but in a "flat ASCII" or "text only"
mode.  Note that adding memory to your computer is <I>not</I> the
way to solve this problem -- you probably have plenty of memory
to run the program once the data file is in the correct format.
<DT><STRONG>"On our Macintosh, larger data files fail to run."</STRONG>
<DD>We have set the memory allowances on the Macintosh executables
to be generous, but not too big.  You therefore may need to
increase them.  Use the <TT>Get Info</TT> item on the Finder <TT>File</TT> menu.
<DT><STRONG>"I opened the program but I don't see where to create
a data file!"</STRONG>
<DD>The programs (there are more than one) use data
files that have been created outside of the program.  They do not have any
data editor within them.  You can create a data file by using an editor,
such as Microsoft Word, EMACS, vi, SimpleText, Notepad, etc.  But be sure
<I>not</I> to save the file in Microsoft Word's own format.  It should be saved in
Text Only format.  You can use the documentation files, including the examples
at the end of those files, to figure out the format of the input file.
Documentation files such as <TT>main.html</TT>, <TT>sequence.html</TT>,
<TT>distance.html</TT> and many others should be consulted.  Many users
create their data files by having their alignment program (such as
ClustalW), output its alignments in PHYLIP format.  Many alignment programs
have options to do that.
menu while the program is selected.
<DT><STRONG>"I ran PHYLIP, and all it did was say it was extracting a bunch of files!"</STRONG>
<DD>
There is no executable program
named <TT>PHYLIP</TT> in the PHYLIP package!  But in some cases
(especially the Windows distribution) there is a file called
<TT>phylip.exe</TT>.
That file is an archive of documentation and source code.  Once you have
run it and extracted the files in it, so that they are in the directory,
running it again will just do the extraction again, which is unnecessary.
Similarly for the archive files for the Windows executables, which
have names like <TT>phylipwx.exe</TT> and <TT>phylipwy.exe</TT>.
They are run only once to extract their contents.
<DT><STRONG>"One program makes an output file and then the next program crashes while reading it!"</STRONG>
<DD>Did you rename the file?  If a program makes a file called <TT>outfile</TT>, and then the
next program is told to use <TT>outfile</TT> as its input file, terrible things will
happen.  The second program first opens <TT>outfile</TT> as an output file, thus
erasing it.  When it then tries to read from this empty <TT>outfile</TT>
a psychological
crisis ensues.  The solution is simply to rename <TT>outfile</TT> before trying to
use it as an input file.
<DT><STRONG>"I make a file called infile and then the program can't find it!"</STRONG>
<DD>Let me guess.  You are using Windows, right?  You made your file in Word or
in Notepad or WordPad, right?  If you made a file in one of these editors, and
saved it, not in Word format, but in Text Only format, then you were doing the
right thing.  But when you told the operating system to save the file as
<TT>infile</TT>, it actually didn't.  It saved it as
<TT>infile.txt</TT>. Then just to make
life harder for you, the operating system is set up by default to not show
that three-letter extension to the file name.  Next to its icon it will show
the name <TT>infile</TT>.  So you think, quite reasonably, that
there is a file called <TT>infile</TT>.  But there isn't a file of that
name, so the program, quite reasonably, can't find a file called
<TT>infile</TT>.  If you want to check what the actual file name is, use
the <TT>Properties</TT>
menu item of the <TT>File</TT> item on your folder (in Windows versions, anyway).  
You should be able to get the program to work by telling it that the file name
is <TT>INFILE.TXT</TT>.
<DT><STRONG>"Consense gives wierd branch lengths! How do I
get more reasonable ones?"</STRONG> 
<DD>Consense gives branch lengths which are simply the numbers of replicates
that support the branch.  This is not a good reflection of how long those
branches are estimated to be.  The best way to put better branch lengths on a
consensus tree is to use it as a User Tree in a program that will estimate
branch lengths for it.  You may need to convert it to being an unrooted tree,
using Retree, first.  If the original program you were using was a parsimony
program, which does not estimate branch lengths, you may instead have to make
some distances between your species (using, for example, DnaDist), and use
Fitch to put branch lengths on the user tree.  Here is the sequence of
steps you should go through:
<OL>
<LI>Take the tree and use Retree to make sure it is Unrooted (just
read it into Retree and then save it, specifying Unrooted)
<LI>Use the unrooted tree as a User Tree (option <TT>U</TT>) in one of
our programs (such as Fitch or DnaML).   If you use Fitch, you also
need to use one of the distance programs such as DnaDist to
compute a set of distances to serve as its input.
<LI>Specify that the branch lengths
of the tree are not to be used but should be re-estimated.  This
is actually the default.
</OL>
<DT><STRONG>"DrawTree (or DrawGram) doesn't work: it can't find the font file!"</STRONG>
<DD>Six font files, called <TT>font1</TT> through <TT>font6</TT>, are
distributed with the executables
(and with the source code too).  The program looks for a copy of one of them
called <TT>fontfile</TT>.  If you haven't made such a copy called
<TT>fontfile</TT> it then asks
you for the name of the font file.  If they are in the current directory, just
type one of <TT>font1</TT> through <TT>font6</TT>.  The reason for
having the program look for <TT>fontfile</TT>
is so that you can copy your favorite font file, call the copy
<TT>fontfile</TT>,
and then it will be found automatically without you having to type the name of
the font file each time.
<DT><STRONG>"Can DrawGram draw a scale beside the tree? Print the branch lengths as numbers?"</STRONG>
<DD>It can't do either of these.  Doing so would make the program more complex, and
it is not obvious how to fit the branch length numbers into a tree that has
many very short internal branches.  If you want these scales or numbers,
choose an output plot file format (such as Postscript, PICT or PCX) that can be read by
a drawing program such as Adobe Illustrator, Freehand, Canvas, CorelDraw,
or MacDraw.
Then you can add the scales and branch length numbers yourself by hand.  Note
the menu option in DrawTree and DrawGram that specifies the tree size to be
a given number of centimeters per unit branch length.
<DT><STRONG>"How can I get DrawGram or DrawTree to print the bootstrap values
next to the branches?"</STRONG>
<DD>When you do bootstrapping and use Consense, it prints the bootstrap
values in its output file (both in a table of sets, and on the diagram
of the tree which it makes).  These are also in the output tree file of
Consense.  There they are in place of branch lengths.  So to get them to
be on the output of DrawGram or DrawTree, you must write the tree in the
format of a drawing program and use it to put the values in by hand, as
mentioned in the answer to the previous question.
<DT><STRONG>"I have an HP Laserjet and can't get DrawGram to print on it"</STRONG>
<DD>DRAWGRAM and DRAWTREE produce a plot file (called <TT>plotfile</TT>): they
do not send it to the printer.  It is up to you to get the plot file to 
the printer.  If you are running Windows or DOS this can probably be done
with the MSDOS command <TT>COPY/B PLOTFILE PRN:</TT>, unless your printer
is a networked printer.  The <TT>/B</TT>
is important.  If it is omitted the copy command will strip off the
highest bit of each byte, which can cause the printing to fail or produce
garbage.
<DT><STRONG>"DNAML won't read the treefile that is produced by DNAPARS!"</STRONG>
<DD>That's because the DnaPars tree file is a rooted tree, and DnaML wants an
unrooted tree.  Try using Retree to change the file to be an unrooted tree
file.</DD>
<DT><STRONG>"In bootstrapping, SEQBOOT makes too large a file"</STRONG>
<DD>If there are 1000 bootstrap replicates, it will make a file
1000 times as long as your original data set.  But for many methods
there is another way that uses much less file space.  You can use
SEQBOOT to make a file of multiple sets of weights, and use those
together with the original data set to do bootstrapping.
<DT><STRONG>"In bootstrapping, the output file gets too big."</STRONG>
<DD> When running a program such as NEIGHBOR or DNAPARS with multiple data
sets (or multiple weights) for purposes of bootstrapping,
the output file is usually not needed, as it
is the output tree file that is used next.  You can use the menu
of the program to turn off the writing of trees into the
output file.  The trees will still be written into the tree file.
<DT><STRONG>"Why doesn't NEIGHBOR read my DNA sequences correctly?"</STRONG>
<DD>Because it  wants
to  have as input a distance matrix, not sequences.  You have to use DNADIST to
make the distance matrix first.
<P>
<H3>How to make it do various things</H3>
<P>
<DT><STRONG>"How do I bootstrap?"</STRONG>
<DD>The general method of bootstrapping
involves  running  SEQBOOT  to make multiple bootstrapped data sets out of your
one data set, then running one of the tree-making programs  with  the  Multiple
data  sets option to analyze them all, then running CONSENSE to make a majority
rule consensus tree from the resulting tree file.  Read  the  documentation  of
SEQBOOT  to  get  further information.  Before, only parsimony methods could be
bootstrapped.  With this new system almost any of the  tree-making  methods  in
the package can be bootstrapped.  It is somewhat more tedious but you will find
it much more rewarding.
<DT><STRONG>"How do I specify a multi-species outgroup
with your parsimony  programs?"</STRONG> 
<DD>It's  not  a  feature  but  is  not too hard to do in many of the programs.  In
parsimony programs like MIX, for which the W (Weights) and A (Ancestral states)
options are available, and weights can be larger than 1, all you need to do is:
<DL COMPACT>
<DT><STRONG>(a)</STRONG>
<DD>In MIX, make up an extra character with states 0 for  all  the  outgroups
and  1  for all the ingroups.  If using DNAPARS the ingroup can have (say)
<TT>G</TT> and the outgroup <TT>A</TT>.
<DT><STRONG>(b)</STRONG>
<DD>Assign this character an enormous weight (such as <TT>Z</TT> for 35) using  the  W
option, all other characters getting weight 1, or whatever weight they had
before.
<DT><STRONG>(c)</STRONG>
<DD>If it is available, Use the A (Ancestral states) option to designate that
for  that  new  character the state found in the outgroup is the ancestral
state.
<DT><STRONG>(d)</STRONG>
<DD>In MIX do not use the O (Outgroup) option.
<DT><STRONG>(e)</STRONG>
<DD>After the tree is found, the designated ingroup  should  have  been  held
together  by the fake character.  The tree will be rooted somewhere in the
outgroup (the program may or may not have a preference for  one  place  in
the  outgroup  over  another).  Make sure that you subtract from the total
number of steps on the tree all steps in the new character.
</DL>
<P>
In programs like DNAPARS, you cannot use this method as weights  of  sites
cannot  be  greater  than  1.   But you do an analogous trick, by adding a
largish number of extra sites to the data, with one nucleotide state ("A")
for the ingroup and another ("G") for the outgroup.  You will then have to
use RETREE to manually reroot the tree in the desired place.
<DT><STRONG>"How do I force certain groups to remain  monophyletic in your
parsimony programs?"</STRONG> 
<DD>By  the same method as in the previous question, using multiple fake characters, any number of
groups of species can be forced to be  monophyletic.   In  MOVE,  DOLMOVE,  and
DNAMOVE  you  can  specify  whatever  outgroups  you want without going to this
trouble.
<DT><STRONG>"How can I reroot one of the trees written out by PHYLIP?"</STRONG>
<DD>Use the program
RETREE.  But keep in mind whether the tree inferred by the original program was
already rooted, or whether you are free to reroot it.
<DT><STRONG>"What do I do  about  deletions  and  insertions  in  my  sequences?"</STRONG>
<DD>The
molecular  sequence  programs  will  accept  sequences  that have gaps (the "<TT>-</TT>"
character).  They do various things with them,  mostly  not  optimal.   DNAPARS
counts  "gap"  as  if it were a fifth nucleotide state (in addition to A, C, G,
and T).  Each site counts one change when a  gap  arises  or  disappears.   The
disadvantage  of  this  treatment is that a long gap will be overweighted, with
one event per gapped site.  So a gap of 10 nucleotides will count as  being  as
much  evidence  as  10  single site nucleotide substitutions.  If there are not
overlapping gaps, one way to correct this is to recode the first  site  in  the
gap  as "<TT>-</TT>" but make all the others be "<TT>?</TT>" so the gap only counts as one event.
Other programs such as DNAML and DNADIST count gaps as  equivalent  to  unknown
nucleotides  (or  unknown  amino  acids) on the grounds that we don't know what
would be there if  something  were  there.   This  completely  leaves  out  the
information  from  the presence or absence of the gap itself, but does not bias
the gapped sequence to be close  to  or  far  from  other  gapped  or  ungapped
sequences.
So it is not necessary to remove gapped regions from your
sequences, unless the presence of gaps indicates that the region is
badly aligned.
<DT><STRONG>"How can I produce distances for my data set which
has 0's and 1's?"</STRONG> 
<DD>You can't do it in a simple and general
way, for a straightforward reason.  Distance methods must correct the
distances for superimposed changes.  Unless we know specifically how to
do this for your particular characters, we cannot accomplish the
correction.  There are many formulas we could use, but we can't choose
among them without much more information.  There are issues of superimposed
changes, as well as heterogeneity of rates of change in different
characters.  Thus we have not provided a distance program for 0/1 data.
It is up to you to figure out what is an appropriate stochastic model
for your data and to find the right distance formulas.
<DT><STRONG>"I have RFLP fragment data: which programs should I
use?"</STRONG>
<DD>This is more difficult question than you may imagine.
Here is quick tour of the issues:
<UL><LI>You can code fragments are 0 and 1 and use a parsimony program.  It is
not obvious in advance whether 0 or 1 is ancestral, though it is likely that
change in one direction is more likely than change in the other for each
fragment.  One can use either Wagner parsimony (programs <TT>MIX</TT>,
<TT>PENNY</TT> or <TT>MOVE</TT>) or use Dollo parsimony
(<TT>DOLLOP, DOLPENNY</TT> or <TT>DOLMOVE</TT>)
with the ancestral states all set as unknown ("<TT>?</TT>").
<LI>You can use a distance matrix method using the RFLP distance of Nei and
Li (1979).  Their restriction fragment distance is available in our
program RestDist. 
<LI>You should be very hesitant to bootstrap RFLP's.  The individual
fragments do not evolve independently: a single nucleotide substitution
can eliminate one fragment and create two (or vice versa).
</UL>
For restriction <I>sites</I> (rather than fragments) life is a bit
easier: they evolve nearly independently so bootstrapping is possible
and <TT>RESTML</TT> can be used.  Also directionality of change
is less ambiguous when parsimony is used.
<DT><STRONG>"Why don't your parsimony programs  print  out  branch  lengths?"</STRONG>
<DD>Well, DNAPARS and PARS can.  The others have not yet been upgraded to the
same level.  The longer answer is that it is because
there  are  problems  defining  the branch lengths.  If you look closely at the
reconstructions of the states of the hypothetical ancestral  nodes  for  almost
any  data  set  and  almost  any  parsimony method you will find some ambiguous
states on those nodes.  There is then usually an ambiguity as to  which  branch
the  change  is  actually  on.  Other parsimony programs resolve this in one or
another arbitrary fashion, sometimes with the user specifying how (for example,
methods  that push the changes up the tree as far as possible or down it as far
as possible).  Our older programs leave it to the user to do this.  In
DNAPARS and PARS we use an algorithm discovered by Hochbaum and Pathria (1997)
(and independently by Wayne Maddison) to compute branch lengths that average
over all possible placements of the changes.  But these branch lengths, as
nice as they are, do not correct for mulitple superimposed changes.  Few
programs  available  from  others  currently  correct  the  branch  lengths for
multiple changes of state that may have overlain each other.  One possible  way
to  get  branch  lengths  with  nucleotide  sequence  data  is to take the tree
topology that you got, use RETREE to convert  it  to  be  unrooted,  prepare  a
distance matrix from your data using DNADIST, and then use FITCH with that tree
as User Tree and see what branch lengths it estimates.
<DT><STRONG>"Why can't your programs handle unordered multistate  characters?"</STRONG>
<DD>In this 3.6 release there is a program PARS which does parsimony for
undordered multistate characters with up to 8 states, plus <TT>?</TT>.  The
other the discrete characters parsimony programs can only handle two states,
<TT>0</TT> and <TT>1</TT>.
This is mostly because I have not yet had time to modify them to do so  -  the
modifications would have to be extensive.  Ultimately I hope to get these done.
If you have four or fewer states and need a feature that is not in PARS,
you could  recode your states to look like nucleotides
and use the parsimony programs in the molecular sequence section of PHYLIP, or
you could use one of the excellent parsimony programs produced by others.
<P>
<H3>Background information needed:</H3>
<P>
<DT><STRONG>"What file format do I use for the sequences?"<BR>
"How do I use the programs?  I can't find any documentation!"</STRONG>
<DD>These are discussed in the documentation files.  Do you have them?  If you
have a copy of this page you probably do.  They are
in a separate archive from the executables (they are in the Documentation and
Sources archives, which you should definitely fetch).  Input file formats
are discussed in <TT>main.html</TT>, in <TT>sequence.html</TT>, <TT>distance.html</TT>,
<TT>contchar.html</TT>, <TT>discrete.html</TT>, and the documentation files for the
individual programs.
<DT><STRONG>"Where can I find out how to infer
phylogenies?</STRONG>
<DD>There are few books yet.  For molecular data you could use one of these:
<UL>
<LI> Graur, D. and W.-H. Li.  2000.  <EM>Fundamentals of Molecular
     Evolution.</EM> Sinauer Associates, Sunderland, Massachusetts. (or the earlier edition
     by Li and Graur).
<LI> Page, R. D. P. and E. C. Holmes.  1998.  <EM>Molecular Evolution: 
     A Phylogenetic Approach.</EM>  Blackwell, Oxford.
<LI> Nei, M. and S. Kumar.  2000.  <EM>Molecular Evolution and
     Phylogenetics.</EM> Oxford University Press, Oxford.
<LI> Li, W.-H.  1999.  <EM>Molecular Evolution.</EM>  Sinauer Associates,
     Sunderland,   Massachusetts.
</UL>
In addition, one of these three review articles may help:
<UL><LI>Swofford, D. L., G. J. Olsen, P. J. Waddell, and D. M. Hillis.  1996.
Phylogenetic inference.  pp. 407-514 in <I>Molecular Systematics</I>, 2nd ed.,
ed.  D. M. Hillis, C. Moritz, and B. K. Mable.  Sinauer Associates, Sunderland,
Massachusetts.
<LI>Felsenstein, J. 1988. Phylogenies from molecular sequences: inference and
reliability.  <I>Annual Review of Genetics</I> <B>22:</B> 521-565.
<LI>Felsenstein, J. 1988. Phylogenies and quantitative
characters. <I>Annual Review of Ecology and Systematics</I> <B>19:</B> 445-471.
</UL>
My own book on phylogenies is due to be published in late 2002.  It
will be called "Inferring Phylogenies".  For information on whether it has
been published you should check the
<A HREF="http://www.sinauer.com">Sinauer Associates web site</A>.
<P>
<H3>Questions about distribution and citation:</H3>
<P>
<DT><STRONG>"If I copied PHYLIP from a friend without you knowing, should I try
to keep  you from finding out?"</STRONG>
<DD>No.  It is to your advantage and mine for you to
let me know.  If you did not get PHYLIP "officially" from me  or  from  someone
authorized  by me, but copied a friend's version, you are not in my database of
users.   You  may also  have  an  old  version  which  has   since   been
substantially  improved.  I  don't  mind  you  "bootlegging"
PHYLIP (it's free anyway), but
you should realize that you may have copied an outdated version. If you are reading this
Web page, 
you can get  the  latest  version  just  as  quickly over Internet.
It will help both of us if you get
onto my mailing list.  If you are on it, then I will give your  name  to  other
nearby  users  when  they ask for the names of nearby users, and they are urged to contact you and
update  your  copy.   (I  benefit  by  getting  a  better  feel  for  how  many
distributions  there have been, and having a better mailing list to use to give
other users local people to contact).  Use the registration form which
can be accessed through our web site's registration page.
<DT><STRONG>"How do I make a citation  to  the  PHYLIP  package in  the  paper I am
writing?"</STRONG> 
<DD>One way is like this:
<P>
Felsenstein, J.  2002.  PHYLIP (Phylogeny Inference Package) version 3.6a3.
<I>Distributed by the author.  Department of Genome Sciences, University of
Washington, Seattle.</I>
<P>
or if the editor for whom you are writing insists that the citation must be  to
a  printed  publication,  you  could cite a notice for version 3.2 published in
Cladistics:
<P>
Felsenstein, J.  1989.  PHYLIP - Phylogeny Inference Package (Version 3.2).
<I>Cladistics</I> <B>5:</B> 164-166.
<BR>
<P>
For a while a printed version of the PHYLIP documentation was available and one
could  cite that.  This is no longer true.  Other than that, this is difficult,
because I have never written a paper announcing  PHYLIP!   My  1985b  paper  in
Evolution on the bootstrap method contains a
one-paragraph Appendix describing the availability of this  package,  and  that
can  also  be  cited  as  a  reference  for  the  package, although it was
distributed since 1980 while the bootstrap paper is 1985.   A paper  on  PHYLIP
is needed mostly to give people something to cite, as word-of-mouth, references
in other people's papers, and electronic newsgroup  postings  have  spread  the
word about PHYLIP's existence quite effectively.
<DT><STRONG>"Can I make copies of PHYLIP available to the students in
my class?"</STRONG>
<DD>Generally, yes.  Read the Copyright notice near the front of
this main documentation page.  If you charge money for PHYLIP,
or use it in a service for which you charge money, you will need
to negotiate a royalty.  But you can make it freely available
and you do not need to get any special permission from us to do so.
<DT><STRONG>"How many copies of PHYLIP have been distributed?"</STRONG>
<DD>On
27 September, 1996 we reached 5,000 registered installations worldwide.
(By now we are well over 15,000 but have lost count for
the moment).  Of course there are
many more people who have got copies from friends.  PHYLIP is the  most  widely
distributed  phylogeny  package. (This situation may reverse itself rapidly
once PAUP* is fully released.  During the years it was in full distribution,
PAUP was ahead in phylogenies published, and the availability of distance and
likelihood methods in PAUP* are making it very popular.)
In recent years  magnetic  tape  distribution and e-mail distribution of
PHYLIP have disappeared,
and there has been a big decrease of diskette distributions (down to only
one or two per year).  But all this has
been  more  than  offset  by, first, an explosion of distributions by anonymous ftp
over Internet, and then a bigger explosion of World Wide Web distributions and
registrations (about 6 registrations per day at the moment).
<P>
<H3>Questions about documentation</H3>
<P>
<DT><STRONG>"Where can I get a printed version of  the  PHYLIP  documents?"</STRONG>
<DD>For  the
moment,  you  can  only  get  a  printed  version by printing it yourself.  For
versions 3.1 to 3.3 a printed version was sold by Christopher Meacham  and  Tom
Duncan,  then  at  the  University Herbarium of the University of California at
Berkeley.  But they have had to discontinue this as it was too much work.   You
should  be  able to print out the documentation files on almost any printer and
make yourself a printed version of whichever of them you need.
<DT><STRONG>"Why have I been dropped from your newsletter mailing list?"</STRONG>
<DD>You haven't.
The  newsletter  was  dropped.  It simply was too hard to mail it out to such a
large mailing list.  The last issue of the newsletter  was  Number  9  in  May,
1987.  The Listserver News Bulletins that we tried for a while have also been dropped
as too hard to keep up to date.  I am hoping that our World Wide Web site will take their place.
</DL>
<P>
<DIV ALIGN="CENTER">
<H3>Additional Frequently Asked Questions, or:</B>
"Why didn't it occur to you to ...</H3></DIV>
<DL>
<DT><STRONG>... allow the options to be set on the command line?</STRONG>
<DD>We could in Unix and Linux, or somewhat differently in Windows.  But
there are so many options that this would be difficult, especially
when the options require additional information to be supplied such as
rates of evolution for many categories of sites.  You may be asking this
question because you want to automate the operation of PHYLIP programs
using batch files (command files) to run in background.  If that is the
issue, see the section of this main documentation page on
"Running the programs in background or under control of a command file".
It explains how to set the options using input redirection and a file
that has the menu responses as keystrokes.
<DT><STRONG>... write these programs in Pascal?"</STRONG>
<DD>These programs started out
in Pascal in 1980.  In 1993 we released both Pascal and C versions.  The
present version (3.6) and
future versions will be C-only.  I make fewer mistakes in Pascal and do
like the language better than C, but C has overtaken Pascal and Pascal
compilers are starting to be hard to find on some machines.  Also C is a
bit better standardized which makes the number of modifications a user
has to make to adapt the programs to their system much less.
<DT><STRONG>... write these programs in Java?"</STRONG>
<DD>Well, we might.  It is not completely clear which of two contenders,
C++ and Java, will become more widespread, and which one will gradually
fade away.  Whichever one is more successful, we will probably want to use
for future versions of PHYLIP.  As the C compilers that are used to
compile PHYLIP are usually also able to compile C++, we will be moving in
that direction, but with constant worrying about whether to convert PHYLIP
to Java instead.</DD>
<DT><STRONG>... forgot about all those inferior systems and just develop PHYLIP for Unix?"</STRONG>
<DD>This is self-answering, since the same people first said I should 
just develop it for Apple II's, then for CP/M Z-80's, then for IBM PCDOS,
then for Macintoshes or for Sun 
workstations, and then for Windows.  If I had listened to them and done any one of these, I would 
have had a very hard time adapting the package to any of the other ones once 
these folks changed their mind (and most of them did)!
<DT><STRONG>... write these programs in PROLOG
(or Ada, or Modula-2, or SIMULA, or BCPL, or PL/I, or APL, or LISP)?"</STRONG>
<DD>These are all languages I have considered.  All
have advantages, but they are not really widespread (as are C and C++).
<DT><STRONG>... include in the package a program to do the Distance Wagner method, (or
successive approximations character weighting,
or transformation series analysis)?"</STRONG>
<DD>In most cases where I have not
included other methods, it is because I decided that they had no substantial
advantages over methods that were included (such as the programs FITCH, 
KITSCH, NEIGHBOR, the <TT>T</TT> option of MIX and DOLLOP, and the "<TT>?</TT>" ancestral
states option of the discrete characters parsimony programs).
<DT><STRONG>... include in the package ordination methods and more
clustering algorithms?"</STRONG>
<DD>Because this is <I>not</I> a clustering package, it's a
package for phylogeny estimation.  Those are different tasks with different
objectives and mostly different methods.  Mary Kuhner and Jon Yamato have,
however,
included in NEIGHBOR an option for UPGMA clustering, which will be very
similar to KITSCH in results.
<DT><STRONG>... include in the package a program to do nucleotide sequence 
alignment?"</STRONG>
<DD>Well, yes, I should
have, and this is scheduled to be in future releases.  But multiple sequence
alignment programs, in the era after Sankoff, Morel, and Cedergren's 1973
classic paper, need to use substantial computer horsepower to estimate the
alignment and the tree together (but see Karl Nicholas's program
<TT>GeneDoc</TT> or Ward Wheeler and David Gladstein's <TT>MALIGN</TT>, as
well as more approximate methods of tree-based alignment used in
<TT>ClustalW</TT> or <TT>TreeAlign</TT>).
</DL>
<P>
<DIV ALIGN="CENTER">
<H3>(Fortunately) obsolete questions</H3></DIV>
<P>
(The following four questions, once
common, have finally disappeared, I am pleased to report).
<H4>"Why didn't it occur to you to ...</H4></DIV>
<DL>
<DT><STRONG>... let me log in to your computer in Seattle
and copy the files out over a phone line?"</STRONG>
<DD>No thanks.  It would cost you for a lot of
long-distance telephone time, plus a half hour of my time and yours in which
I had to explain to you how to log in and do the copying.
<DT><STRONG>... send me a listing of your program?"</STRONG>
<DD>Damn it, it's not "a program",
it's 35 programs, in a great many files.  What were you
thinking of doing, having 1800-line programs typed in by slaves at your
end?  If you were going to go to all that trouble why not try network
transfer?  If you have these then you can print out all the
listings you want to and add them to the huge stack of printed output in
the corner of your office.
<DT><STRONG>... write a magnetic tape in our computer center's favorite format
(inverted Lithuanian EBCDIC at 998 bpi)?"</STRONG>
<DD>Because the ANSI standard
format is the most widely used one, and even though your computer center
may pretend it can't read a tape written this way, if you sniff around
you will find a utility to read it.  It's just a <I>lot</I> easier for me to
let you do that work.  If I tried to put the tape into your format, I
would probably get it wrong anyway.
<DT><STRONG>... give us a version of these in FORTRAN?"</STRONG>
<DD>Because the
programs are <I>far</I> easier to write and debug in C or Pascal, and cannot
easily be
rewritten into FORTRAN (they make extensive use of recursive calls and
of records and pointers).  In any case, C is widely available.  If you don't
have a C compiler or don't know
how to use it, you are going to have to learn a language like C or
Pascal sooner or later, and the sooner the better.
</DL>
<P>
<A NAME="newfeatures"><HR><P></A>
<DIV ALIGN="CENTER">
<H2>New Features in This Version</H2></DIV>
<P>
Version 3.6 has many new features:
<UL><LI>Faster (well, less, slow) likelihood programs.
<LI>The DNA and protein likelihood and distance programs allow
for rate variation between sites using a gamma distribution of
rates among sites, or using a gamma distribution plus a given
fraction of sites which are assumed invariant.
<LI>A new multistate discrete characters parsimony program, PARS, that
handles unordered multistate characters.
<LI>The DNAPARS and PARS parsimony programs can infer multifurcating
trees, which sensibly reduces the number of tied trees they find.
<LI>A new protein sequence likelihood program, <TT>PROML</TT>,
and also a version, <TT>PROMLK</TT> which assumes a molecular clock.
<LI>A new restriction sites and restriction fragments distance program,
<TT>RESTDIST</TT>, that can also be used to compute distances for RAPD and
AFLP data.  It also allows for gamma-distributed rate variation among
DNA sites.
<LI>In the DNA likelihood programs, you can now specify different
categories of rates of change (such as rates for first, second, and
third positions of a coding sequence) and assign them to specific sites.
This is in addition to the ability of the program to use the Hidden Markov
Model mechanism to allow rates of change to vary across sites in a way that
does not ask you to assign which rate goes with which site.
<LI>The input files for many of the programs are now
simpler, in that they do not contain options information such as specification
of weights and categories.  That information is now provided in separete
files with default names such as <TT>weights</TT> and <TT>categories</TT>.
<LI>The DNA likelihood programs can now evaluate multifurcating
user trees (option <TT>U</TT>).
<LI>All programs that read in user-defined trees now do so from a separate
file, whose default name is <TT>intree</TT>, rather than requiring them to
be in the input file as before.
<LI>The DNA likelihood programs can infer the sequence at ancestral
nodes in the interior of the tree.
<LI>DNAPARS can now do transversion parsimony.
<LI>The bootstrapping program SEQBOOT now can, instead of producing a
large file containing multiple data sets, be asked instead
to produce a weights file with multiple sets of weights.  Many
programs in this release can analyze those multiple weights together with
the original data set, which saves disk space.
<LI>The bootstrapping program SEQBOOT can pass weights and categories
information through to a multiple weights file or a multiple categories
file.
<LI>SEQBOOT can also convert sequence files from Interleaved to
Sequential form, or back.
<LI>SEQBOOT can also write a sequence data file into a preliminary version of
a new XML format which is being defined for sequence alignments,
for use by programs that need XML input
(none of the current PHYLIP programs yet need this format, but it
will be useful in the future).
<LI>RETREE can now write tree out into a preliminary version of a new XML tree
file format which is in the process of being defined.
<LI>The Kishino-Hasegawa-Templeton (KHT) test which compares user-defined
trees (option U) is now joined by the Shimodaira-Hasegawa (SH) test
(Shimodaira and Hasegawa, 1999) which corrects for comparisons among
multiple tests.  This avoids a statistical problem with multiple user trees.
<LI>CONTRAST can now carry out an analysis that takes into account
within-species variation, according to a model similar (but not
identical) to that introduced by Michael Lynch (1990)
<LI>A new program, TREEDIST, computes the Robinson-Foulds symmetric
difference distance among trees.  This measures the number of branches in
the trees that are present in one but not the other.
<LI>FITCH and KITSCH now have an option to make trees by the
minimum evolution distance matrix method.
<LI>The protein parsimony program PROTPARS now allows you to choose among
a number of different genetic codes such as mitochondrial codes.
<LI>The consensus tree program CONSENSE
can compute the M<SUB>l</SUB> family of consensus tree methods, which
generalize the Majority Rule consensus tree method. It can
also compute our extended Majority Rule consensus (which is
Majority Rule with some additional groups added to resolve the
tree more completely), and it can also compute the original
Majority Rule consensus tree method which does not add these
extra groups.  It can also
compute the Strict consensus.
<LI>The tree-drawing programs DRAWGRAM and DRAWTREE have a number of new
options of kinds of file they can produce, including Windows Bitmap files,
files for the Idraw and FIG X windows drawing programs, the POV ray-tracer,
and even VRML Virtual Reality Markup Language files that will enable you
to wander around the tree using a VRML plugin for your browser, such as
Cosmo Player.
<LI>DRAWTREE now uses my new Equal Daylight Algorithm to draw unrooted
trees.  This gives a much better-looking tree.  Of course, competing programs
such as TREEVIEW and PAUP draw trees that look just as good - because they
too have started to use my method (with my encouragement).  DRAWTREE also
can use another algorithm, the n-body method.
<LI>The tree-drawing programs can now produce trees across multiple
pages, which is handy for looking at trees with very large numbers
of tips, and for producing giant diagrams by pasting together
multiple sheets of paper.
</UL>
<P>
There are many more, lesser features added as well.
<P>
<A NAME="future"><HR><P></A>
<DIV ALIGN="CENTER">
<H2>Coming Attractions, Future Plans</H2></DIV>
<P>
There are some obvious deficiencies in this version.  Some of these
holes will be filled in the next few releases (leading to version
4.0).  They include:
<OL>
<LI>A program to align molecular sequences on a predefined User Tree may
ultimately be included.  This will allow alignment and phylogeny
reconstruction to procede iteratively by successive runs of two programs, one
aligning on a tree and the other finding a better tree based on that alignment.
In the shorter run a simple two-sequence alignment program may be included.
<LI>An interactive "likelihood explorer" for DNA sequences will be written.
This will allow, either with or without the assumption of a molecular
clock, trees to be varied interactively so that the user can get a much
better feel for the shape of the likelihood surface.  Likelihood will be
able to be plotted against branch lengths for any branch.
<LI>If possible we will find some way of correcting for purine/pyrimidine
richness variations among species, within the framework of the maximum
likelihood programs.  That they maximum likelihood programs do not allow
for base composition variation is their major limitation at the moment.
<LI>The Hidden Markov Model (regional rates) option of DNAML and DNAMLK will
be generalized to allow
for rates at sites to gradually change as one moves along the tree,
in an attempt to implement Fitch and Markowitz's (1970) notion of "covarions".
<LI>Obviously we need to start thinking about a more visual mouse/windows
interface, but only if that can be used on X windows, Macintoshes, and
Windows.
<LI>Program PENNY and its relatives will improved so as to run faster
and find all most parsimonious trees more quickly.
<LI>A more sophisticated compatibility program should be included, if I can
find one.
<LI>An "evolutionary clock" version of CONTML will be done, and the same 
may also be done for RESTML.
<LI>We are gradually generalizing the tree structures in the programs to
infer multifurcating trees as well as bifurcating ones.
We should be able to have any program read any tree and know what to do
with it, without the user having to fret about whether an unrooted tree was
fed to a program that needs a rooted tree.
<LI>We are economizing on the size of the source code, and enforcing some
standardization of it, by putting frequently used routines in separate
files which can be linked into various programs.  This will enforce
a rather complete standardization of our code.
<LI>We will move our code to an object-oriented
language, most lkely C++.  One could describe the language that version
3.4 was written in as "Pascal", version 3.5 as "Pascal written in C",
version 3.6 as "C written in C", and maybe version 4.0 as "C++ written
in C" and then 4.1 as "C++ written in C++".  At least that scenario
is one possibility.
</OL>
<P>
Much of the future development of the package will be in the DNA and protein
likelihood programs and the distance matrix programs.  This is for several
reasons.  First, I am more interested in those problems.  Second, collection of
molecular data is increasing rapidly, and those programs have the most promise
for future development
for those data.
<P>
<A NAME="endorsements"><HR><P></A>
<DIV ALIGN="CENTER">
<H2>Endorsements</H2></DIV>
<P>
Here are some comments people have made in print about PHYLIP.  Explanatory
material in square brackets is my own.  They fall naturally into two groups:
<P>
<H3>From the pages of <I>Cladistics</I>:</H3>
<P>
<BLOCKQUOTE>
"Under no circumstances can we recommend PHYLIP/WAG [their name for the
Wagner parsimony option of MIX]."
<DIV ALIGN="RIGHT">
Luckow, M. and R. A. Pimentel (1985)
</DIV>
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>
"PHYLIP has not proven very effective in implementing parsimony (Luckow and
Pimentel, 1985)."
<DIV ALIGN="RIGHT">
J. Carpenter (1987a)
</DIV>
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>
"... PHYLIP.  This is the computer program where every newsletter concerning
it is mostly bug-catching, some of which have been put there by previous
corrections.  As Platnick (1987) documents, through dint of much labor useful
results may be attained with this program, but I would suggest an
easier way: FORMAT b:"
<DIV ALIGN="RIGHT">
J. Carpenter (1987b)
</DIV>
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>
"PHYLIP is bug-infested and both less effective and orders of
magnitude slower than other programs ...."
<DIV ALIGN="RIGHT">
"T. N. Nayenizgani" [J. S. Farris] (1990)
</DIV>
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>
"Hennig86 [by J. S. Farris] provides such substantial improvements over
previously available programs (for both mainframes and microcomputers) that
it should now become the tool of choice for practising systematists."
<DIV ALIGN="RIGHT">
N. Platnick (1989)
</DIV>
</BLOCKQUOTE>
<P>
<H3>... and in the pages of other journals:</H3>
<P>
<BLOCKQUOTE>
"The availability, within PHYLIP of distance, compatibility, maximum likelihood,
and generalized `invariants' algorithms (Cavender and Felsenstein, 1987) sets
it apart from other packages .... One of the strengths of PHYLIP is its
documentation ...."
<DIV ALIGN="RIGHT">
Michael J. Sanderson (1990)
</DIV>
<EM>(Sanderson also criticizes PHYLIP for slowness and inflexibility of its
parsimony algorithms, and compliments other packages on their strengths).</EM>
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>
"This package of programs has gradually become a basic necessity to anyone
working seriously on various aspects of phylogenetic inference .... The package
includes more programs than any other known phylogeny package.  But it is not
just a collection of cladistic and related programs.  The package has great
value added to the whole, and for this it is unique and of extreme
importance .... its various strengths are in the great array of methods
provided ...."
<DIV ALIGN="RIGHT">
Bernard R. Baum (1989)
</DIV>
</BLOCKQUOTE>
<P>
(note also W. Fink's critical remarks (1986) on version 2.8 of PHYLIP).
<P>
<A NAME="references"><HR><P></A>
<DIV ALIGN="CENTER">
<H2>References for the Documentation Files</H2></DIV>
<P>
In the documentation files that follow I frequently refer to papers
in the literature.  In order to centralize the references they are given
in this section.  The chapter by David Swofford,
Gary Olsen, Peter Waddell, and David Hillis
(1996) is also an excellent review of the issues in phylogeny
reconstruction.
If you want to find further papers beyond these, my
Quarterly Review of Biology review of 1982 and my Annual Review of Genetics
review of 1988 list many further references.
<P>
Adams, E. N.  1972.  Consensus techniques and the comparison of
taxonomic trees.  <I>Systematic Zoology</I> <B>21:</B> 390-397.
<P>
Adams, E. N.  1986.  N-trees as nestings: complexity, similarity, and
consensus.  <I>Journal of Classification</I> <B>3:</B> 299-317.
<P>
Archie, J. W.  1989.  A randomization test for phylogenetic information in
systematic data.  <I>Systematic Zoology</I> <B>38:</B> 219-252.
<P>
Barry, D., and J. A. Hartigan.  1987.  Statistical analysis of hominoid
molecular evolution.  <I>Statistical Science</I>  <B>2:</B> 191-210.
<P>
Baum, B. R.  1989.  PHYLIP: Phylogeny Inference Package. Version 3.2. (Software
review).  <I>Quarterly Review of Biology</I> <B>64:</B> 539-541.
<P>
Bron, C., and J. Kerbosch.  1973.  Algorithm 457: Finding all cliques
of an undirected graph.  <I>Communications of the Association for Computing Machinery</I> <B>16:</B> 575-577.
<P>
Camin, J. H., and R. R. Sokal.  1965.  A method for deducing branching
sequences in phylogeny.  <I>Evolution</I> <B>19:</B> 311-326.
<P>
Carpenter, J.  1987a.  A report on the Society for the Study of Evolution
workshop "Computer Programs for Inferring Phylogenies".  <I>Cladistics</I> <B>3:</B>
363-375.
<P>
Carpenter, J.  1987b.  Cladistics of cladists.  <I>Cladistics</I> <B>3:</B> 363-375.
<P>
Cavalli-Sforza, L. L., and A. W. F. Edwards.  1967.  Phylogenetic
analysis: models and estimation procedures.  <I>Evolution</I> <B>32:</B> 550-570
(also <I>American Journal of Human Genetics</I> <B>19:</B> 233-257).
<P>
Cavender, J. A. and J. Felsenstein.  1987.  Invariants of phylogenies in a
simple case with discrete states.  <I>Journal of Classification</I> <B>4:</B> 57-71.
<P>
Churchill, G.A.  1989.  Stochastic models for heterogeneous DNA sequences.
<I>Bulletin of Mathematical Biology</I> <B>51:</B> 79-94.
<P>
Conn, E. E. and P. K. Stumpf.  1963.  <I>Outlines of Biochemistry.</I>  John Wiley
and Sons, New York.
<P>
Day, W. H. E.  1983.  Computationally difficult parsimony problems in
phylogenetic systematics.  <I>Journal of Theoretical Biology</I> <B>103:</B>
429-438.
<P>
Dayhoff, M. O. and R. V. Eck.  1968.  <I>Atlas of Protein Sequence
and Structure 1967-1968.</I>  National Biomedical Research Foundation,
Silver Spring, Maryland.
<P>
Dayhoff, M. O., R. M. Schwartz, and B. C. Orcutt.  1979.  A model of
evolutionary change in proteins.  pp. 345-352 in <I>Atlas of
Protein Sequence and Structure, volume 5, supplement 3, 1978,</I> ed.
M. O. Dayhoff.  National Biomedical Research Foundation, Silver Spring, Maryland
.
<P>
Dayhoff, M. O.  1979.  <I>Atlas of Protein Sequence and Structure, Volume 5,
Supplement 3, 1978.</I>  National Biomedical Research Foundation, Washington, D.C.
<P>
DeBry, R. W. and N. A. Slade.  1985.  Cladistic analysis of restriction
endonuclease cleavage maps within a maximum-likelihood framework.
<I>Systematic Zoology</I> <B>34:</B>  21-34.
<P>
Dempster, A. P., N. M. Laird, and D. B. Rubin.  1977.  Maximum
likelihood from incomplete data via the EM algorithm.  <I>Journal of the Royal Statistical Society B</I> <B>39:</B> 1-38.
<P>
Eck, R. V., and M. O. Dayhoff.  1966.  <I>Atlas of Protein Sequence and
Structure 1966.</I>  National Biomedical Research Foundation, Silver
Spring, Maryland.
<P>
Edwards, A. W. F., and L. L. Cavalli-Sforza.  1964.  Reconstruction of
evolutionary trees.  pp. 67-76 in <I>Phenetic and Phylogenetic
Classification,</I> ed. V. H. Heywood and J. McNeill. Systematics
Association Volume No. 6. Systematics Association, London.
<P>
Estabrook, G. F., C. S. Johnson, Jr., and F. R. McMorris.  1976a.  A
mathematical foundation for the analysis of character
compatibility.  <I>Mathematical Biosciences</I> <B>23:</B> 181-187.
<P>
Estabrook, G. F., C. S. Johnson, Jr., and F. R. McMorris.  1976b.  An
algebraic analysis of cladistic characters.  <I>Discrete Mathematics</I> <B>16:</B> 141-147.
<P>
Estabrook, G. F., F. R. McMorris, and C. A. Meacham.  1985.  Comparison of
undirected phylogenetic trees based on subtrees of four evolutionary units.
<I>Systematic Zoology</I> <B>34:</B> 193-200.
<P>
Faith, D. P.  1990.  Chance marsupial relationships.  <I>Nature</I><B>345:</B> 393-394.
<P>
Faith, D. P. and P. S. Cranston.  1991.  Could a cladogram this short have
arisen by chance alone?: On permutation tests for cladistic
structure.  <I>Cladistics</I> <B>7:</B> 1-28.
<P>
Farris, J. S.  1977.  Phylogenetic analysis under Dollo's Law.  <I>Systematic Zoology</I> <B>26:</B> 77-88.
<P>
Farris, J. S.  1978a.  Inferring phylogenetic trees from chromosome
inversion data.  <I>Systematic Zoology</I> <B>27:</B> 275-284.
<P>
Farris, J. S.  1981.  Distance data in phylogenetic analysis.  pp. 3-23
in <I>Advances in Cladistics: Proceedings of the first meeting of the
Willi Hennig Society,</I> ed. V. A. Funk and D. R. Brooks.  New York
Botanical Garden, Bronx, New York.
<P>
Farris, J. S.  1983.  The logical basis of phylogenetic analysis.  pp. 1-47
in <I>Advances in Cladistics, Volume 2, Proceedings of the Second Meeting of
the Willi Hennig Society.</I>  ed. Norman I. Platnick and V. A. Funk.  Columbia
University Press, New York.
<P>
Farris, J. S.  1985.  Distance data revisited.  <I>Cladistics</I> <B>1:</B> 67-85.
<P>
Farris, J. S.  1986.  Distances and statistics.  <I>Cladistics</I> <B>2:</B> 144-157. 
<P>
Farris, J. S. ["T. N. Nayenizgani"].  1990.  The systematics association
enters its golden years (review of <I>Prospects in Systematics</I>, ed. D.
Hawksworth).  <I>Cladistics</I> <B>6:</B> 307-314.
<P>
Felsenstein, J.  1973a.  Maximum likelihood and minimum-steps methods
for estimating evolutionary trees from data on discrete characters.
<I>Systematic Zoology</I> <B>22:</B> 240-249.
<P>
Felsenstein, J.  1973b.  Maximum-likelihood estimation of evolutionary
trees from continuous characters.  <I>American Journal of Human Genetics</I> <B>25:</B>
471-492.
<P>
Felsenstein, J.  1978a.  The number of evolutionary trees.  <I>Systematic Zoology</I> <B>27:</B> 27-33.
<P>
Felsenstein, J.  1978b.  Cases in which parsimony and compatibility
methods will be positively misleading.  <I>Systematic Zoology</I> <B>27:</B>
401-410.
<P>
Felsenstein, J.  1979.  Alternative methods of phylogenetic inference
and their interrelationship.  <I>Systematic Zoology</I> <B>28:</B> 49-62.
<P>
Felsenstein, J.  1981a.  Evolutionary trees from DNA sequences: a
maximum likelihood approach.  <I>Journal of Molecular Evolution</I> <B>17:</B> 368-376.
<P>
Felsenstein, J.  1981b.  A likelihood approach to character weighting
and what it tells us about parsimony and compatibility.  <I>Biological Journal of the Linnean Society</I> <B>16:</B> 183-196.
<P>
Felsenstein, J.  1981c.  Evolutionary trees from gene frequencies and
quantitative characters: finding maximum likelihood estimates.
<I>Evolution</I> <B>35:</B> 1229-1242.
<P>
Felsenstein, J.  1982.  Numerical methods for inferring evolutionary
trees.  <I>Quarterly Review of Biology</I> <B>57:</B> 379-404.
<P>
Felsenstein, J.  1983b.  Parsimony in systematics: biological and
statistical issues. <I>Annual Review of Ecology and Systematics</I> <B>14:</B> 313-333.
<P>
Felsenstein, J. 1984a.  Distance methods for inferring phylogenies: a
justification. <I>Evolution</I> <B>38:</B> 16-24.
<P>
Felsenstein, J.  1984b.  The statistical approach to inferring
evolutionary trees and what it tells us about parsimony and
compatibility.  pp. 169-191 in: <I>Cladistics: Perspectives in the
Reconstruction of Evolutionary History,</I> edited by T. Duncan and T. F.
Stuessy.  Columbia University Press, New York.
<P>
Felsenstein, J.  1985a.  Confidence limits on phylogenies with a molecular
clock.  <I>Systematic Zoology</I> <B>34:</B> 152-161.
<P>
Felsenstein, J.  1985b.  Confidence limits on phylogenies: an approach
using the bootstrap.  <I>Evolution</I> <B>39:</B> 783-791. 
<P>
Felsenstein, J.  1985c.  Phylogenies from gene frequencies: a statistical
problem.  <I>Systematic Zoology</I> <B>34:</B> 300-311.
<P>
Felsenstein, J.  1985d.  Phylogenies and the comparative method.  <I>American Naturalist</I> <B>125:</B> 1-12.
<P>
Felsenstein, J.  1986.  Distance methods: a reply to Farris.  <I>Cladistics</I> <B>2:</B>
130-144.
<P>
Felsenstein, J.  and E. Sober.  1986.  Parsimony and likelihood: an
exchange.  <I>Systematic Zoology</I> <B>35:</B> 617-626.
<P>
Felsenstein, J.  1988a.  Phylogenies and quantitative characters.  <I>Annual Review of Ecology and Systematics</I> <B>19:</B> 445-471.
<P>
Felsenstein, J.  1988b.  Phylogenies from molecular sequences: inference and 
reliability.   <I>Annual Review of Genetics</I> <B>22:</B> 521-565.
<P>
Felsenstein, J.  1992.  Phylogenies from restriction sites, a
maximum likelihood approach.  <I>Evolution</I> <B>46:</B> 159-173.
<P>
Felsenstein, J. and G. A. Churchill. 1996.
A hidden Markov model approach to variation among sites in rate of evolution
<I>Molecular Biology and Evolution</I> <B>13:</B> 93-104.
<P>
Fink, W. L.  1986.  Microcomputers and phylogenetic analysis.  <I>Science</I> <B>234:</B> 1135-1139.
<P>
Fitch, W. M., and E. Markowitz.  1970.  An improved method for determining
codon variability in a gene and its application to the rate of fixation of
mutations in evolution.  <I>Biochemical Genetics</I> <B>4:</B> 579-593.
<P>
Fitch, W. M., and E. Margoliash.  1967.  Construction of phylogenetic
trees.  <I>Science</I> <B>155:</B> 279-284.
<P>
Fitch, W. M.  1971.  Toward defining the course of evolution: minimum
change for a specified tree topology.  <I>Systematic Zoology</I> <B>20:</B> 406-416.
<P>
Fitch, W. M.  1975.  Toward finding the tree of maximum parsimony.  pp. 189-230
in Proceedings of the Eighth International Conference on Numerical Taxonomy,
ed. G. F. Estabrook.  W. H. Freeman, San Francisco.
<P>
Fitch, W. M. and E. Markowitz.  1970.  An improved method for determining
codon variability and its application to the rate of fixation of mutations
in evolution.  <I>Biochemical Genetics</I> <B>4:</B> 579-593.
<P>
George, D. G.,  L. T. Hunt, and W. C. Barker.  1988.  Current methods in
sequence comparison and analysis.  pp. 127-149 in Macromolecular Sequencing
and Synthesis, ed. D. H. Schlesinger.  Alan R. Liss, New York.
<P>
Gomberg, D.  1966.  "Bayesian" post-diction in an evolution process.
unpublished manuscript: University of Pavia, Italy.
<P>
Graham, R. L., and L. R. Foulds.  1982.  Unlikelihood that minimal
phylogenies for a realistic biological study can be constructed in
reasonable computational time.  <I>Mathematical Biosciences</I> <B>60:</B> 133-142.
<P>
Hasegawa, M. and T. Yano.  1984a.  Maximum likelihood method of phylogenetic
inference from DNA sequence data.  <I>Bulletin of the Biometric Society of Japan</I>  No. 5:  1-7.
<P>
Hasegawa, M.  and T. Yano.  1984b.  Phylogeny and classification of
Hominoidea as inferred from DNA sequence data.  <I>Proceedings of the Japan Academy</I> <B>60 B:</B> 389-392.
<P>
Hasegawa, M., Y. Iida, T. Yano, F. Takaiwa, and M. Iwabuchi.  1985a.
Phylogenetic relationships among eukaryotic kingdoms as inferred from
ribosomal RNA sequences.  Journal of Molecular Evolution  22: 32-38.
<P>
Hasegawa, M., H. Kishino, and T. Yano.  1985b.  Dating of the human-ape
splitting by a molecular clock of mitochondrial DNA.  Journal of Molecular
Evolution  22: 160-174.
<P>
Hendy, M. D., and D. Penny.  1982.  Branch and bound algorithms to
determine minimal evolutionary trees.  <I>Mathematical Biosciences</I> <B>59:</B> 277-290.
<P>
Higgins, D. G. and P. M. Sharp.  1989.  Fast and sensitive
multiple sequence alignments on a microcomputer.  <I>Computer Applications in the Biological Sciences (CABIOS)</I> <B>5:</B> 151-153.
<P>
Hochbaum, D. S. and A. Pathria.  1997.  Path costs in evolutionary
tree reconstruction.  <I>Journal of Computational Biology</I> <B>4:</B> 163-175.
<P>
Holmquist, R., M. M. Miyamoto, and M. Goodman.  1988.  Higher-primate
phylogeny - why can't we decide?  <I>Molecular Biology and Evolution</I> <B>5:</B> 201-216.
<P>
Inger, R. F.  1967.  The development of a phylogeny of frogs. 
<I>Evolution</I> <B>21:</B> 369-384.
<P>
Jin, L. and M. Nei.  1990.  Limitations of the evolutionary parsimony method
of phylogenetic analysis.  <I>Molecular Biology and Evolution</I> <B>7:</B> 82-102.
<P>
Jones, D. T., W. R. Taylor and J. M. Thornton. 1992. The rapid generation of
mutation data matrices from protein sequences. <I>Computer Applications
in the Biosciences (CABIOS)</I> <B>8:</B> 275-282.
<P>
Jukes, T. H. and C. R. Cantor.  1969.  Evolution of protein molecules.  pp. 
21-132 in Mammalian Protein Metabolism, ed. H. N. Munro.  Academic Press, New 
York.
<P>
Kidd, K. K. and L. A. Sgaramella-Zonta.  1971.  Phylogenetic analysis: concepts
and methods.  <I>American Journal of Human Genetics</I> <B>23:</B> 235-252.
<P>
Kim, J.  and M. A. Burgman.  1988.  Accuracy of phylogenetic-estimation 
methods using simulated allele-frequency data.  <I>Evolution</I> <B>42:</B> 596-602.
<P>
Kimura, M.  1980.  A simple model for estimating evolutionary rates of base 
substitutions through comparative studies of nucleotide sequences.  <I>Journal of Molecular Evolution</I> <B>16:</B> 111-120.
<P>
Kimura, M.  1983.  The Neutral Theory of Molecular Evolution.  Cambridge
University Press, Cambridge.
<P>
Kingman, J. F. C.  1982a.  The coalescent.  <I>Stochastic Processes and Their Applications</I> <B>13:</B> 235-248.
<P>
Kingman, J. F. C.  1982b.  On the genealogy of large populations.  <I>Journal of Applied Probability</I> <B>19A:</B> 27-43.
<P>
Kishino, H. and M. Hasegawa.  1989. Evaluation of the maximum likelihood
estimate of the evolutionary tree topologies from DNA sequence data, and the
branching order in Hominoidea.  <I>Journal of Molecular Evolution</I> <B>29:</B> 170-179.
<P>
Kluge, A. G., and J. S. Farris.  1969.  Quantitative phyletics and the
evolution of anurans.  <I>Systematic Zoology</I> <B>18:</B> 1-32.
<P>
Kuhner, M. K. and J. Felsenstein.  1994.  A simulation comparison of
phylogeny algorithms under equal and unequal evolutionary rates.
<I>Molecular Biology and Evolution</I> <B>11:</B> 459-468 (Erratum <B>12:</B> 525 &nbsp;1995).
<P>
K&uuml;nsch, H. R.  1989.  The jackknife and the bootstrap for general stationary
observations.  <I>Annals of Statistics</I> <B>17:</B> 1217-1241.
<P>
Lake, J. A.  1987.  A rate-independent technique for analysis of nucleic acid
sequences: evolutionary parsimony.  <I>Molecular Biology and Evolution</I> <B>4:</B> 167-191.
<P>
Lake, J. A.  1994.  Reconstructing evolutionary trees from DNA and protein
sequences: paralinear distances.
<I>Proceedings of the Natonal Academy of Sciences, USA</I> <B>91:</B> 1455-1459.
<P>
Le Quesne, W. J.  1969.  A method of selection of characters in
numerical taxonomy.  <I>Systematic Zoology</I> <B>18:</B> 201-205.
<P>
Le Quesne, W. J.  1974.  The uniquely evolved character concept and its
cladistic application.  <I>Systematic Zoology</I> <B>23:</B> 513-517.
<P>
Lewis, H. R., and C. H. Papadimitriou.  1978.  The efficiency of
algorithms.  <I>Scientific American</I> <B>238:</B> 96-109 (January issue)
<P>
Lockhart, P. J., M. A. Steel, M. D. Hendy, and D. Penny.  1994.
Recovering evolutionary trees under a more realistic model of sequence
evolution.  <I>Molecular Biology and Evolution</I> <B>11:</B> 605-612.
<P>
L&oacute;pez-Mart&iacute;nez, N.; &Aacute;lvarez-Sierra, 
M. A. &amp; Garc&iacute;a Moreno, E. 1986. Paleontolog&iacute;a y
Bioestratigraf&iacute;a 
(Micromam&iacute;feros) del Mioceno medio-superior del Sector Central de 
la Cuenca del Duero. <I>Stvdia Geologica Salmanticensia</I>
<B>22:</B> 146-191.
<P>
Luckow, M.  and D. Pimentel.  1985.  An empirical comparison of
numerical Wagner computer programs.  <I>Cladistics</I> <B>1:</B> 47-66.
<P>
Lynch, M.  1990.  Methods for the analysis of comparative data in evolutionary
biology.  <I>Evolution</I> <B>45:</B> 1065-1080.
<P>
Maddison, D. R.  1991.  The discovery and importance of multiple islands of
most-parsimonious trees.  <I>Systematic Zoology</I> <B>40:</B> 315-328.
<P>
Margush, T. and F. R. McMorris.  1981.  Consensus n-trees.  <I>Bulletin of Mathematical Biology</I> <B>43:</B> 239-244.
<P>
Nelson, G.  1979.  Cladistic analysis and synthesis: principles and definitions,
with a historical note on Adanson's <I>Familles des Plantes</I>
(1763-1764).  <I>Systematic Zoology</I> <B>28:</B> 1-21.
<P>
Nei, M.  1972.  Genetic distance between populations.  <I>American Naturalist</I> <B>106:</B> 283-292.
<P>
Nei, M.  and W.-H. Li.  1979.  Mathematical model for studying genetic variation
in terms of restriction endonucleases.  <I>Proceedings of the National Academy of Sciences, USA</I> <B>76:</B> 5269-5273.
<P>
Page, R. D. M.  1989.  Comments on component-compatibility in historical
biogeography.  <I>Cladistics</I> <B>5:</B> 167-182.
<P>
Penny, D. and M. D. Hendy.  1985.  Testing methods of evolutionary tree 
construction.  <I>Cladistics</I> <B>1:</B> 266-278.
<P>
Platnick, N.  1987.   An empirical comparison of microcomputer parsimony
programs.  <I>Cladistics</I> <B>3:</B> 121-144.
<P>
Platnick, N.  1989.  An empirical comparison of microcomputer parsimony
programs. II.  <I>Cladistics</I> <B>5:</B> 145-161.
<P>
Reynolds, J. B., B. S. Weir, and C. C. Cockerham.  1983.  Estimation of the 
coancestry coefficient: basis for a short-term genetic 
distance.  <I>Genetics</I> <B>105:</B> 767-779.
<P>
Robinson, D. F. and L. R. Foulds.  1981.  Comparison of phylogenetic trees.
<I>Mathematical Biosciences</I> <B>53:</B> 131-147.
<P>
Rohlf, F. J.  and M. C. Wooten.  1988.  Evaluation of the restricted maximum 
likelihood method for estimating phylogenetic trees using simulated allele-
frequency data.  <I>Evolution</I> <B>42:</B> 581-595.
<P>
Rzhetsky, A., and M. Nei.  1992.  Statistical properties of the ordinary
least-squares, generalized least-squares, and minimum-evolution methods
of phylogenetic inference. <I>Journal of Molecular Evolution</I> <B>35:</B>
367-375 .
<P>
Saitou, N., Nei, M.  1987.  The neighbor-joining method: a new method for
reconstructing phylogenetic trees.  <I>Molecular Biology and Evolution</I> <B>4:</B> 406-425.
<P>
Sanderson, M. J.  1990.  Flexible phylogeny reconstruction: a review of
phylogenetic inference packages using parsimony.  <I>Systematic Zoology</I> <B>39:</B> 414-420.
<P>
Sankoff, D. D., C. Morel, R. J. Cedergren.  1973.  Evolution of 5S RNA and
the nonrandomness of base replacement.  <I>Nature New Biology</I> <B>245:</B> 232-234.
<P>
Shimodaira, H. and M. Hasegawa.  1999.  Multiple comparisons of log-likelihoods
with applications to phylogenetic inference.  <EM>Molecular Biology and
Evolution</EM> <B>16:</B> 1114-1116.
<P>
Sokal, R. R. and P. H. A. Sneath.  1963.  <I>Principles of Numerical Taxonomy.</I>
W. H. Freeman, San Francisco.
<P>
Smouse, P. E. and W.-H. Li.  1987.  Likelihood analysis of mitochondrial
restriction-cleavage patterns for the human-chimpanzee-gorilla trichotomy.
<I>Evolution</I> <B>41:</B> 1162-1176.
<P>
Sober, E.  1983a.  Parsimony in systematics: philosophical issues.  <I>Annual Review of Ecology and Systematics</I> <B>14:</B> 335-357.
<P>
Sober, E.  1983b.  A likelihood justification of parsimony.  <I>Cladistics</I> <B>1:</B> 209-233.
<P>
Sober, E.  1988.  <I>Reconstructing the Past: Parsimony, Evolution,
and Inference.</I>  MIT Press, Cambridge, Massachusetts.
<P>
Sokal, R. R., and P. H. A. Sneath.  1963.  <I>Principles of Numerical
Taxonomy.</I>  W. H. Freeman, San Francisco.
<P>
Steel, M. A.  1994.  Recovering a tree from the Markov leaf colourations
it generates under a Markov model.  <I>Applied Mathematics Letters</I>
<B>7:</B> 19-23.
<P>
Studier, J. A.  and K. J. Keppler.  1988.  A note on the neighbor-joining
algorithm of Saitou and Nei.  <I>Molecular Biology and Evolution</I><B>5:</B> 729-731.
<P>
Swofford, D. L. and G. J. Olsen.  1990.  Phylogeny reconstruction.  Chapter
11, pages 411-501 in <I>Molecular Systematics,</I> ed. D. M. Hillis and C. Moritz.
Sinauer Associates, Sunderland, Massachusetts.
<P>
Swofford, D. L., G. J. Olsen, P. J. Waddell, and D. M. Hillis.  1996.
Phylogenetic inference.  pp. 407-514 in <I>Molecular Systematics</I>, 2nd ed.,
ed.  D. M. Hillis, C. Moritz, and B. K. Mable.  Sinauer Associates, Sunderland,
Massachusetts.
<P>
Templeton, A. R.  1983.  Phylogenetic inference from restriction endonuclease
cleavage site maps with particular reference to the evolution of humans and the
apes. <I>Evolution</I> <B>37:</B> 221-244.
<P>
Thompson, E. A.  1975.  <I>Human Evolutionary Trees.</I>  Cambridge University
Press, Cambridge.
<P>
Wu, C. F. J.  1986.  Jackknife, bootstrap and other resampling plans in 
regression analysis.  <I>Annals of Statistics</I> <B>14:</B> 1261-1295.
<P>
Yang, Z. 1993.  Maximum-likelihood estimation of phylogeny from DNA sequences
when substitution rates differ over sites.  <I>Molecular Biology and
Evolution</I> <B>10:</B> 1396-1401.
<P>
Yang, Z. 1994.  Maximum likelihood phylogenetic estimation from DNA sequences
with variable rates over sites: approximate methods.  <I>Journal of Molecular
Evolution</I> <B>39:</B> 306-314.
<P>
Yang, Z.  1995.  A space-time process model for the evolution of DNA sequences.
<I>Genetics</I> <B>139:</B> 993-1005.
<P>
<DIV ALIGN="CENTER">
<H2>Credits</H2></DIV>
<P>
Over the years various granting agencies have contributed to the
support of the PHYLIP project (at first without knowing it).  They are:
<P>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT">Years</TD>
<TD ALIGN="LEFT">Agency</TD>
<TD ALIGN="LEFT">Grant or Contract Number</TD>
</TR>
<TR><TD ALIGN="LEFT">1999-2002</TD>
<TD ALIGN="LEFT">NSF</TD>
<TD ALIGN="LEFT">BIR-9527687</TD>
</TR>
<TR><TD ALIGN="LEFT">1999-2002</TD>
<TD ALIGN="LEFT">NIH NIGMS</TD>
<TD ALIGN="LEFT">R01 GM51929-04</TD>
</TR>
<TR><TD ALIGN="LEFT">1999-2001</TD>
<TD ALIGN="LEFT">NIH NIMH</TD>
<TD ALIGN="LEFT">R01 HG01989-01</TD>
</TR>
<TR><TD ALIGN="LEFT">1995-1999</TD>
<TD ALIGN="LEFT">NIH NIGMS</TD>
<TD ALIGN="LEFT">R01 GM51929-01</TD>
</TR>
<TR><TD ALIGN="LEFT">1992-1995 </TD>
<TD ALIGN="LEFT">National Science Foundation</TD>
<TD ALIGN="LEFT">DEB-9207558</TD>
</TR>
<TR><TD ALIGN="LEFT">1992-1994</TD>
<TD ALIGN="LEFT">NIH NIGMS Shannon Award</TD>
<TD ALIGN="LEFT">2 R55 GM41716-04</TD>
</TR>
<TR><TD ALIGN="LEFT">
1989-1992</TD>
<TD ALIGN="LEFT">NIH NIGMS</TD>
<TD ALIGN="LEFT">1 R01-GM41716-01</TD>
</TR>
<TR><TD ALIGN="LEFT">
1990-1992</TD>
<TD ALIGN="LEFT">National Science Foundation</TD>
<TD ALIGN="LEFT">BSR-8918333</TD>
</TR>
<TR><TD ALIGN="LEFT">
1987-1990</TD>
<TD ALIGN="LEFT">National Science Foundation</TD>
<TD ALIGN="LEFT">BSR-8614807</TD>
</TR>
<TR><TD ALIGN="LEFT">1979-1987</TD>
<TD ALIGN="LEFT">U.S. Department of Energy</TD>
<TD ALIGN="LEFT">DE-AM06-76RLO2225 TA DE-AT06-76EV71005</TD>
</TR>
</TABLE>
<P>
I am particularly grateful to program administrators William Moore,
Irene Eckstrand, Peter Arzberger, and Conrad Istock, who have
gone beyond the call of duty to make sure that PHYLIP continued.
<P>
Booby prizes for funding are awarded to:
<UL><LI>The people at the U.S. Department of Energy who, in 1987, decided they
were "not interested in phylogenies",
<LI>The members of the Systematics Panel of NSF who twice (in 1989 and 1992)
positively recommended that my applications <I>not</I> be funded.  I am very
grateful to program director William Moore for courageously overruling
their decision the first time.  The 1992 NSF Systematics Panel could claim
no credit for PHYLIP whatsoever.
<LI>The members of the 1992 Genetics Study Section of NIH who rated my
proposal in the 53rd percentile (I don't know if that's 53rd from
the top or the bottom, but does it matter?), thus denying it funding.  I am,
however, grateful to the NIGMS administrators, especially Irene Eckstrand,
who supported giving me
a "Shannon award" partially funding my work for a period in spite of this
rating.
</UL>
<P>
The original Camin-Sokal parsimony program and the polymorphism parsimony 
program were written by me in 1977 and 1978.  They were Pascal versions of 
earlier FORTRAN programs I wrote in 1966 and 1967 using the same algorithm to 
infer phylogenies under the Camin-Sokal and polymorphism parsimony 
criteria.  Harvey Motulsky worked for me as a programmer in 1971 and wrote 
FORTRAN programs to carry out the Camin-Sokal, Dollo, and polymorphism 
methods (he is known these days as the author of the scientific
graphing package GraphPad).  But most of the early work on PHYLIP other than my own was by Jerry 
Shurman and Mark Moehring.  Jerry Shurman worked for me in the summers of 
1979 and 1980, and Mark Moehring worked for me in the summers of 1980 and 
1981.  Both wrote original versions of many of the other programs, based on 
the original versions of my Camin-Sokal parsimony program and POLYM.  These 
formed the basis of Version 1 of the Package, first distributed in October, 
1980. 
<P>
Version 2, released in the spring of 1982, involved a fairly complete rewrite 
by me of many of those programs.  Hisashi Horino for
version 3.3 reworked some parts of the programs CLIQUE and CONSENSE
to make their output more comprehensible, and has added some code to the
tree-drawing programs DRAWGRAM and DRAWTREE as well.  He also worked on
some of the Drawtree and Drawgram driver code.
<P>
My more recent part-time programmers Akiko Fuseki, Sean Lamont,
Andrew Keeffe, Daniel Yek, Dan Fineman, Patrick Colacurcio,
Mike Palczewski, and Doug Buxton gave
me substantial help with the current release, and their excellent work is
greatly appreciated.  Akiko in particular did much of the hard work of adding
new features and changing old ones in the 3.4 and 3.5 releases,
centralized many of the C routines in support files, and is responsible for the
new versions of DNAPARS and PARS. Andrew
prepared the Macintosh version, wrote RETREE, added the ray-tracing
and PICT code to the DRAW programs and has since done much other work.  Sean
was central to the conversion to
C, and tested it extensively.  My postdoctoral fellow
Mary Kuhner and her associate Jon Yamato created NEIGHBOR, the
neighbor-joining and UPGMA program, for the current release, for which I am
also grateful (Naruya Saitou and Li Jin kindly encouraged us to use some of the
code from their own implementation of this method).
<P>
I am very grateful to over 200
users for algorithmic suggestions, complaints about features (or lack of
features), and information about the behavior of their operating systems
and compilers.  A list of some of their names will be found at the credits page
on the PHYLIP web site.
<P>
A major contribution to this package has been made by others
writing programs or parts of programs.  Chris Meacham contributed the
important program FACTOR, long demanded by users, and the even more
important ones PLOTREE and PLOTGRAM.  Important parts of the code in
DRAWGRAM and DRAWTREE were taken over from those two programs.
Kent Fiala wrote
function "reroot" to do outgroup-rooting, which was an essential part of many
programs in earlier versions.  Someone at the Western Australia Institute of
Technology suggested the name PHYLIP (by writing it the label on the
outside of a magnetic tape), but they all seem to deny having done
so (and I've lost the relevant letter).
<P>
The distribution of the package also owes much to Buz Wilson and Willem Ellis, 
who put a lot of effort into the early distributions of the PCDOS and
Macintosh versions respectively.  Christopher Meacham and Tom Duncan for three
versions distributed a printed version of these documentation files (they are no
longer able to do so), and I am
very grateful to them for those efforts.  William H.E. Day and F. James Rohlf
have been very helpful in setting up the listserver news bulletin service which
succeeded the PHYLIP newsletter for a time.
<P>
I also wish to thank the people who have made computer resources available to
me, mostly in the loan of use of microcomputers.  These include Jeremy
Field, Clem Furlong, Rick Garber, Dan Jacobson, Rochelle Kochin, Monty Slatkin,
Jim Archie, Jim Thomas, and George Gilchrist.
<P>
I should also note the computers used to develop this package:
These include a CDC 6400, two DECSystem 1090s, my trusty old SOL-20, my
old Osborne-1, a VAX 11/780, a VAX 8600, a MicroVAX I, a DECstation
3100, my old Toshiba 1100+, my 
DECstation 5000/200, a DECstation 5000/125, a Compudyne 486DX/33, a
Trinity Genesis 386SX, a Zenith Z386, a Mac Classic, a DEC Alphastation 400
4/233, a Pentium 120, a Pentium 200, a PowerMac 6100, and a Macintosh G3.
(One of the reasons
we have been successful in achieving compatibility between different computer
systems is that I have had to run them myself under so many different operating
systems and compilers).
<P>
<A NAME="otherprograms"><HR><P></A>
<DIV ALIGN="CENTER">
<H2>Other Phylogeny Programs Available Elsewhere</H2></DIV>
<P>
A comprehensive list of phylogeny programs is maintained at the PHYLIP
web site on the Phylogeny Programs pages:
<P>
<DIV ALIGN="CENTER">
<FONT SIZE=+2><A HREF="http://evolution.gs.washington.edu/phylip/software.html">
<TT>http://evolution.gs.washington.edu/phylip/software.html</TT></FONT></A></DIV>
<P>
Here we will simply mention some of the major general-purpose programs.  For
many more and much more, see those web pages.
<P>
<B>PAUP*</B>&nbsp;&nbsp;  A comprehensive program with parsimony, likelihood, and
distance matrix methods.  It competes with PHYLIP to be responsible for
the most trees published.  Written by David Swofford and distributed by
Sinauer Associates of Sunderland, Massachusetts.
It is described in a web pages for
<A HREF="http://www.sinauer.com/detail.php?id=8060">the Macintosh version,</A>
<A HREF="http://www.sinauer.com/detail.php?id=8079">the Windows version,</A>
and
<A HREF="http://www.sinauer.com/detail.php?id=8044">the Unix/OpenVMS version.</A>
Current prices are $100 for the Macintosh version, $85 for the
Windows version, and $150 for Unix versions for many kinds of workstations.
<P>
<B>MacClade</B>&nbsp;&nbsp;   An interactive Macintosh and PowerMac program to
rearrange trees and watch the changes in the fit of the trees to
data as judged by parsimony.  MacClade has a great many features including
a spreadsheet data editor and many different descriptive statistics
for different kinds of data.  It is particularly designed to export and
import data to and from PAUP*.
MacClade is available for $100 from Sinauer Associates, of Sunderland,
Massachusetts.  It is described in a web page at
<A HREF="http://www.sinauer.com/detail.php?id=4707">
<TT>http://www.sinauer.com/detail.php?id=4707</TT></A>.
MacClade is also described on its <A HREF="http://phylogeny.arizona.edu/macclade/macclade.html">
Web page</A>, at <CODE>http://phylogeny.arizona.edu/macclade/macclade.html</CODE
>.
<P>
<B>MEGA</B>&nbsp;&nbsp;  A Windows and DOS program by Sudhir Kumar of Arizona State University
(written together with Koichiro Tamura and Masatoshi Nei while he was a
student in Nei's lab at Pennsylvania
State University).  It can carry out parsimony and distance matrix methods
for DNA sequence data.  Version 2.1 for Windows
can be downloaded from <A HREF="http://www.megasoftware.net">
the MEGA web site</A>
at <TT>http://www.megasoftware.net</TT>.
<P>
<B>PAML</B>&nbsp;&nbsp;  Ziheng Yang of the Department of Genetics and Biometry at
University College, London has written this package of programs to
carry out likelihood analysis of DNA and protein sequence data.  PAML is
particularly strong in the options for coping with variability of rates
of evolution from site to site, though it is less able than some other
packages to search effectively for the best tree.  It is available as
C source code and as PowerMac and Windows executables from its web site at
<A HREF="http://abacus.gene.ucl.ac.uk/software/paml.html">
<TT>http://abacus.gene.ucl.ac.uk/software/paml.html</TT></A>.
<P>
<B>TREE-PUZZLE</B>&nbsp;&nbsp;  This package by Korbinian Strimmer and Arndt von Haeseler
was begun when they were at the Uviversit&auml;t Munchen in Germany.
TREE-PUZZLE can carry out likelihood
methods for DNA and protein data, searching by the strategy of
"quartet puzzling" which they invented.  It can also compute distances.
It superimposes trees estimated
from many quartets of species.  TREE-PUZZLE is available for Unix, Macintoshes,
or Windows from their web site at
<A HREF="http://www.tree-puzzle.de/"><TT>http://www.tree-puzzle.de/</TT></A>.
<P>
<B>DAMBE</B> &nbsp;&nbsp; A package written by Xuhua Xia, then of the
Department of
Ecology and Biodiversity of the University of Hong Kong.
Its initials stand for Data Analysis in Molecular Biology and Evolution.
DAMBE is a general-purpose package for DNA and protein sequence phylogenies.
It can read and
convert a number of file formats, and has many features for
descriptive statistics, and can compute a number of commonly-used
distance matrix measures and infer phylogenies by parsimony, distance,
or likelihood methods, including bootstrapping and jackknifing.  There are
a number of kinds of statistical tests of trees available and it
can also display phylogenies.  DAMBE includes a copy of ClustalW as well;
DAMBE consists of Windows95 executables.  It is available from its
web site at <A HREF="http://web.hku.hk/~xxia/software/software.htm">
<CODE>http://web.hku.hk/~xxia/software/software.htm</CODE></A>.
Xia has now moved to the Department of Biology of the University of Ottawa,
Canada, and I suspect the DAMBE web site will soon follow him there.
<P>
<B>MOLPHY</B>&nbsp;&nbsp;  A package of programs for carrying out likelihood analysis
of DNA and protein data, written by Jun Adachi and Masami Hasegawa of the
Institute of Statistical Mathematics in Tokyo, Japan.  The source code
is available from them at
<A HREF="http://www.ism.ac.jp/software/ismlib/softother.e.html">
the MOLPHY web site</A> at
<CODE>http://www.ism.ac.jp/software/ismlib/softother.e.html</CODE>, and
Windows executables are available from Russell Malmberg's web site at
<A HREF="http://dogwood.botany.uga.edu/malmberg/software.html">
<TT>http://dogwood.botany.uga.edu/malmberg/software.html</TT></A>.
<P>
<B>Hennig86</B>&nbsp;&nbsp;  A fast parsimony program by J. S. Farris of the
Naturhistoriska Riksmuseet in Stockholm, Sweden for discrete characters
data (it can handle DNA if its states are recoded to be digits).
Reputed to be faster than PAUP*.
The program is distributed as an executable and costs $50, plus $5
mailing costs ($10 outside of of the U.S.). The user's name should be stated,
as copies are personalized as a copy-protection measure. It is
distributed by Arnold Kluge, Amphibians and Reptiles, Museum of Zoology,
University of
Michigan, Ann Arbor, Michigan 48109-1079, U.S.A. (<TT>akluge@umich.edu</TT>) and
by Diana Lipscomb at George Washington University (<TT>BIODL@gwuvm.gwu.edu</TT>).
<P>
<B>RnA</B>&nbsp;&nbsp;  J. S. Farris's very fast program which uses parsimony
to carry out jackknifing resampling of DNA sequence data.  This would be
nearly equivalent in properties to bootstrapping if the jackknifing were
sampling random halves of the data, but Farris prefers to have each
jackknife sample delete a fraction 1/<I>e</I> of the data, which will give
most groups too much support (he would disagree with this statement).
RnA is available from Arnold Kluge, Amphibians and Reptiles, Museum of Zoology,
University of
Michigan, Ann Arbor, Michigan 48109-1079, U.S.A. (<TT>akluge@umich.edu</TT>)
and Diana Lipscomb
at George Washington University (<TT>BIODL@gwuvm.gwu.edu</TT>) who may be
contacted for details.  The cost is about $30 US. 
<P>
<B>NONA</B>&nbsp;&nbsp;  Pablo Goloboff, of the Instituto Miguel Lillo in
Tucuman, Argentina has written these very fast parsimony programs, capable
of some relevant forms of weighted parsimony, which can handle either
DNA sequence data or discrete characters.  It is available as shareware
from <A HREF="http://www.cladistics.com/aboutNona.htm">
<TT>http://www.cladistics.com/aboutNona.htm</TT></A>
There is a 30 day free trial, after which
NONA must be purchased separately by sending a check for $40.00 to
either directly to the the author, or to: James M. Carpenter, Attn: NONA,
Division of Invertebrate Zoology, American Museum of Natural History,
Central Park West at 79th Street, New York, NY 10024.
<P>
<B>TNT</B> This program, by Pablo Goloboff, J. S. Farris, and Kevin Nixon,
is for searching large data sets for most parsimonious trees. 
The authors are respectively at the Instituto Miguel Lillo in Tucuman,
Argentina, the Naturhistoriska Riksmuseet in Stockholm, Sweden, and the
Hortorium, Cornell University, Ithaca, New York.
TNT is described
as faster than other methods, though not faster than NONA for small to
medium data sets.  Its distribution status is somewhat uncertain.  The site
<A HREF="http://www.cladistics.com/aboutTNT.html">
<TT>http://www.cladistics.com/aboutTNT.html</TT></A>
describes it as unavailable,
while the web site <A HREF="http://www.cladistics.com/webtnt.html">
<TT>http://www.cladistics.com/webtnt.html</TT></A> makes a beta version
available for download.  The program downloaded is free but needs a password to
function, which the user should obtain from Pablo Goloboff (see the latter
web page for details).
<P>
These are only a few of the more than 194 different phylogeny packages that
are now available (as of January, 2001 - the number keeps increasing).  The
others are described (and web links and ftp addresses provided) at my
Phylogeny Programs web pages at the address given above.
<P>
<A NAME="helpme"><HR><P></A>
<DIV ALIGN="CENTER">
<H2>How You Can Help Me</H2></DIV>
<P>
Simply let me know of any problems you have had adapting the
programs to your computer.  I can often make "transparent" changes that, by
making the code avoid the wilder, woolier, and less standard parts of
C, not only help others who have your machine but even improve the
chance of the programs functioning on new machines.  I would like fairly
detailed information on what gave trouble, on what operating system,
machine, and (if relevant) compiler, and what had to be done to make the
programs work.  I am sometimes able to do some over-the-telephone
trouble-shooting, particularly
if I don't have to pay for the call, but electronic mail is a the best
way for me to be asked about problems, as you can include your
input and output files so I can see what is going on (please do <EM>not</EM>
send them as Attachments, but as part of the body of a message).  I'd really
like these programs to be
able to run with only routine changes on <I>absolutely everything</I>, down to
and possibly including the Amana Touchmatic Radarange Microwave Oven
which was an Intel 8080 system (in fact, early versions of this package did
run successfully on Intel 8080 systems running the CP/M operating system).
A PalmPilot version is contemplated too.
<P>
I would also like to know timings of programs from the package, when
run on the three test input files provided above, for various computer and
compiler combinations, so that I can provide this information in the
section on speeds of this document.
<P>
For the phylogeny plotting programs DRAWGRAM and DRAWTREE,
I am particularly interested in knowing what has to be done
to adapt them for other graphic file formats.
<P>
You can also be helpful to PHYLIP users in your part of the world by
helping them get the latest version of PHYLIP from our web site
and by helping them with any
problems they may have in getting PHYLIP working on their data.
<P>
Your help is appreciated.  I am always happy to hear suggestions
for features and programs that ought to be incorporated in the package,
but please do not be upset if I turn out to have already considered the
particular possibility you suggest and decided against it.
<P>
<A NAME="trouble"><HR><P></A>
<DIV ALIGN="CENTER">
<H2>In Case of Trouble</H2></DIV>
<P>
<I>Read The (documentation) Files Meticulously</I> ("RTFM").  If that doesn't solve the
problem, please check the Frequently Asked Questions web page at the
PHYLIP web site:
<P>
<FONT SIZE=+2>
<TT><A HREF="http://evolution.gs.washington.edu/phylip/faq.html">
http://evolution.gs.washington.edu/phylip/faq.html</TT></A></FONT>
<P>
and the PHYLIP Bugs web page at that site:
<P>
<FONT SIZE=+2>
<TT><A HREF="http://evolution.gs.washington.edu/phylip/bugs.html">
http://evolution.gs.washington.edu/phylip/bugs.html</TT></A></FONT>
<P>
If none of these answers your question, get in touch with me.  My electronic mail address
is given below.  If you do ask about a problem, please specify the program
name, version of the package, computer operating system, and
send me your data file so I can test the problem.  Do <I>not</I>
send your data file as an e-mail Attachment but instead
as the body of a message. I read the e-mail on a Unix system, which makes
it impossible to read some formats of attachments without
running around to other machines and moving the files there. This
is one of my least favorite activities, so please do not use attachments.
Also it will help if you 
have the relevant output and documentation files so that you
can refer to them in any correspondence.  I can also be reached by telephone
by calling me in my office: 
+1-(206)-543-0150, or at home: +1-(206)-526-9057 (how's <I>that</I> for user
support!).  If I cannot be reached at either place, a message can be left at
the office of
the Department of Genome Sciences, (206)-221-7377 but I prefer strongly that I not
call you, as in any phone consultation the least you can do is pay the phone
bill.  Better yet, use electronic mail.
<P>
Particularly if you are in a part of the world distant from me, you may also 
want to try to get in touch with other users of PHYLIP nearby.  I can also,
if requested, provide a list of nearby users.
<P>
<DIV ALIGN="RIGHT">
<TABLE><TR><TD ALIGN=LEFT>
Joe Felsenstein<BR>
Department of Genome Sciences<BR>
University of Washington<BR>
Box 357730<BR>
Seattle, Washington 98195-7730, U.S.A.
</TD></TR></TABLE>
</DIV>
<P>
Electronic mail addresses: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<TT>joe@gs.washington.edu</TT>
<BR><HR>
</BODY>
</HTML>
